<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Route Map</title>
  
  <style>
    /* 1. Basic Setup */
    html, body { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
      font-family: 'Segoe UI', Tahoma, sans-serif; 
    }
    
    #map { 
      height: 100%; 
      width: 100%; 
    }

    /* 2. Search Bar Styling (Hidden Initially) */
    #pac-input {
      display: none; /* âœ… Hidden until map is IDLE */
      background-color: #fff;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      font-size: 15px;
      font-weight: 400;
      margin: 10px;
      padding: 0 13px;
      width: 300px;
      height: 40px;
      border: 1px solid #dadce0;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      outline: none;
    }

    /* 3. Route Summary Box (Hidden Initially) */
    .route-summary {
      display: none; /* âœ… Hidden until route calculated */
      background: white; 
      padding: 14px 18px;
      border-radius: 12px; 
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      font-size: 14px; 
      line-height: 1.5;
      direction: rtl; 
      text-align: right; 
      min-width: 160px; 
      border: 1px solid #eee;
      margin-left: 10px;
      margin-bottom: 25px;
    }
    
    .route-summary h3 {
      color: #1a73e8; 
      border-bottom: 1px solid #eee;
      padding-bottom: 5px; 
      margin: 0 0 8px 0;
      font-size: 15px;
    }

    /* 4. Legend Styling (Hidden Initially) */
    .legend {
      display: none; /* âœ… Hidden until map is IDLE */
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      margin-bottom: 25px; 
      margin-right: 10px;
      min-width: 140px;
    }
    
    .legend-row { display: flex; align-items: center; margin-bottom: 6px; }
    .legend-color { width: 14px; height: 14px; border-radius: 50%; margin-left: 6px; }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&callback=initMap&libraries=marker,places,geometry&loading=async&v=weekly" async defer></script>
</head>

<body>
  <input id="pac-input" type="text" placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù†ÙˆØ§Ù† Ø£Ùˆ Ø§Ø³Ù… Ø·Ø§Ù„Ø¨..." />
  
  <div id="legend" class="legend">
    <div class="legend-row"><div class="legend-color" style="background:#00c853"></div><span>Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Start)</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#d50000"></div><span>Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (End)</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#9C27B0"></div><span>Ø§Ù„Ù…Ø±Ø§ÙÙ‚ (Escort)</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#1a73e8"></div><span>Ø·Ù„Ø§Ø¨ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¬ÙˆÙ„Ø©</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#ff9100"></div><span>Ø·Ù„Ø§Ø¨ Ø¨Ø¯ÙˆÙ† Ø¬ÙˆÙ„Ø§Øª</span></div>
  </div>

  <div id="route-summary" class="route-summary">
    <h3>ğŸ“ Ù…Ù„Ø®Øµ Ø§Ù„Ø¬ÙˆÙ„Ø©</h3>
    <div id="summary-text">â€”</div>
  </div>

  <div id="map"></div>

  <script>
    // --- Globals ---
    window.routeMarkers = [];
    window.availableMarkers = [];
    let map, directionsService, directionsRenderer, infoWindow;
    let mapReady = false;

    const MY_MAP_ID = "48c2bb983bd19c1c44d95cb7";

    // 1. HELPER: Calculate Distance
    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // 2. HELPER: Group nearby stops
    function groupCloseLocations(stops, tolerance = 15) {
      const clusters = [];
      stops.forEach(stop => {
        let placed = false;
        
        // Normalize data
        const type = (stop.stopType || "").toLowerCase().trim();
        const shift = (stop.timeShift || "").toUpperCase().trim();

        for (const c of clusters) {
          const d = haversineDistance(c.lat, c.lng, parseFloat(stop.lat), parseFloat(stop.lng));
          if (d < tolerance) {
            c.items.push(stop);
            if (stop.isStart === true) c.isStart = true;
            if (stop.isFinal === true) c.isFinal = true;
            
            if (type === 'assistant') {
              c.stopType = 'assistant';
              if (shift) c.timeShift = shift;
            }
            c.hideMarker = c.hideMarker && (stop.hideMarker === true || stop.hideMarker === 'true');
            placed = true;
            break;
          }
        }
        if (!placed) {
          clusters.push({
            lat: parseFloat(stop.lat),
            lng: parseFloat(stop.lng),
            items: [stop],
            isStart: stop.isStart === true,
            isFinal: stop.isFinal === true,
            stopType: type,
            timeShift: shift,
            hideMarker: (stop.hideMarker === true || stop.hideMarker === 'true')
          });
        }
      });
      return clusters;
    }

    // 3. UI: Update Summary Box
    function updateRouteSummary(km, minutes) {
      const summaryBox = document.getElementById("route-summary");
      const summaryText = document.getElementById("summary-text");
      if (summaryBox && summaryText) {
        summaryBox.style.display = "block"; // Show when data is ready
        summaryText.innerHTML = "Ø§Ù„Ù…Ø³Ø§ÙØ©: <b>" + km + " ÙƒÙ…</b><br>Ø§Ù„ÙˆÙ‚Øª: <b>" + minutes + " Ø¯Ù‚ÙŠÙ‚Ø©</b>";
      }
    }

    // 4. MAIN: Initialize Map
    window.initMap = async function() {
      try {
        const { Map } = await google.maps.importLibrary("maps");
        const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");
        const { Places } = await google.maps.importLibrary("places");

        infoWindow = new google.maps.InfoWindow();

        // Initialize Map
        map = new Map(document.getElementById("map"), {
          center: { lat: 32.028031, lng: 35.704308 }, // Default: School Location
          zoom: 13,
          mapId: MY_MAP_ID,
          mapTypeControl: true,
          streetViewControl: true,
          fullscreenControl: false
        });

        // --- SETUP CONTROLS ---
        const input = document.getElementById("pac-input");
        const legend = document.getElementById("legend");
        const summary = document.getElementById("route-summary");

        // Push controls to Map (Still hidden by CSS)
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
        map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(legend);
        map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(summary);

        const autocomplete = new google.maps.places.Autocomplete(input);
        autocomplete.bindTo("bounds", map);

        // âœ… FIX: Reveal UI Controls when map is IDLE (Fully Loaded)
        google.maps.event.addListenerOnce(map, 'idle', () => {
           input.style.display = "block";
           legend.style.display = "block";
        });

        // --- SEARCH LISTENER ---
        autocomplete.addListener("place_changed", () => {
            const place = autocomplete.getPlace();
            const searchText = (place.name || input.value || "").toLowerCase();

            // 1. SEARCH OUR STUDENT DATA FIRST
            const allMarkers = [...window.routeMarkers, ...window.availableMarkers];
            const foundStudent = allMarkers.find(m => 
                m.names.some(studentName => studentName.toLowerCase().includes(searchText))
            );

            if (foundStudent) {
                map.setCenter({ lat: foundStudent.lat, lng: foundStudent.lng });
                map.setZoom(19);
                infoWindow.setContent(foundStudent.html);
                infoWindow.open(map, foundStudent.marker);
                return;
            }

            // 2. SEARCH GOOGLE MAPS (Fallback)
            if (!place.geometry || !place.geometry.location) return;

            if (place.geometry.viewport) {
                map.fitBounds(place.geometry.viewport);
            } else {
                map.setCenter(place.geometry.location);
                map.setZoom(17);
            }
        });

        // Initialize Directions
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            map: map,
            suppressMarkers: true,
            preserveViewport: true,
            polylineOptions: { strokeColor: "#1a73e8", strokeOpacity: 0.8, strokeWeight: 5 },
        });

        mapReady = true;
        console.log("âœ… Route Map Initialized");

        if (window.pendingData) {
            window.setRouteData(window.pendingData.route, window.pendingData.available);
            window.pendingData = null;
        }

      } catch (e) {
        console.error("âŒ initMap Failed:", e);
      }
    };

    // 5. DATA HANDLER: Receive Data from Flutter
    window.addEventListener("message", function (event) {
      if (!event.data || event.data.action !== "setRouteData") return;
      
      const routeData = event.data.routeData || [];
      const availableData = event.data.availableData || [];
      
      console.log("ğŸ“© Data Received:", routeData.length, "Route Items");

      if (mapReady) {
         window.setRouteData(routeData, availableData);
      } else {
         window.pendingData = { route: routeData, available: availableData };
      }
    });

    window.setRouteData = function(routeArray, availableArray) {
      // Clear old markers
      window.routeMarkers.forEach(obj => obj.marker.map = null);
      window.availableMarkers.forEach(obj => obj.marker.map = null);
      window.routeMarkers = [];
      window.availableMarkers = [];
      directionsRenderer.setDirections({ routes: [] });
      
      // Hide summary until recalculated
      document.getElementById("route-summary").style.display = "none";

      const bounds = new google.maps.LatLngBounds();

      const addMarker = (pos, title, html, color, text, studentNames) => {
        const pin = new google.maps.marker.PinElement({
            background: color,
            borderColor: "#FFFFFF",
            glyphColor: "#FFFFFF",
            glyphText: text 
        });

        const marker = new google.maps.marker.AdvancedMarkerElement({
            map: map,
            position: pos,
            content: pin.element,
        });

        marker.addListener("click", () => {
            infoWindow.setContent(html);
            infoWindow.open(map, marker);
        });

        return { 
            marker, 
            pin, 
            names: studentNames || [], 
            html: html, 
            lat: pos.lat, 
            lng: pos.lng 
        };
      };

      const routeClusters = groupCloseLocations(routeArray);
      const availableClusters = groupCloseLocations(availableArray);

      // --- RENDER ROUTE MARKERS ---
      routeClusters.forEach(cluster => {
        if (cluster.hideMarker) return;
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);

        let color = "#1a73e8"; 
        let initialText = "...";
        let headerTitle = "Ù†Ù‚Ø·Ø© ØªÙˆÙ‚Ù";

        if (cluster.isStart) {
            color = "#00c853"; initialText = "S"; headerTitle = "Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©";
        } else if (cluster.isFinal) {
            color = "#d50000"; initialText = "E"; headerTitle = "Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©";
        } else if (cluster.stopType === 'assistant') {
            color = "#9C27B0"; 
            initialText = cluster.timeShift === 'AM' ? "A" : "P";
            headerTitle = "Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ (" + cluster.timeShift + ")";
        }

        let studentRows = cluster.items.map(function(x) {
            let name = x.studentName || "Ø·Ø§Ù„Ø¨";
            let details = (x.gradeName || "") + " " + (x.sectionName || "");
            return '<div style="margin-bottom:6px; border-bottom:1px solid #eee; padding-bottom:4px;">' +
                   '<b>' + name + '</b><br>' +
                   '<span style="font-size:12px; color:#555;">' + details + '</span>' +
                   '</div>';
        }).join('');

        let html = '<div style="color:black;text-align:right;direction:rtl;min-width:180px;">' +
                   '<b style="color:' + color + '; font-size:14px;">' + headerTitle + '</b><hr>' +
                   studentRows +
                   '</div>';

        let namesArr = cluster.items.map(x => x.studentName || "");
        const markerObj = addMarker(pos, "route", html, color, initialText, namesArr);
        window.routeMarkers.push(markerObj);
      });

      // --- RENDER AVAILABLE MARKERS ---
      availableClusters.forEach(cluster => {
        if (cluster.hideMarker) return;
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);

        let studentRows = cluster.items.map(function(x) {
            let name = x.studentName || "Ø·Ø§Ù„Ø¨";
            let details = (x.gradeName || "") + " " + (x.sectionName || "");
            return '<div style="margin-bottom:6px; border-bottom:1px solid #eee; padding-bottom:4px;">' +
                   '<b>' + name + '</b><br>' +
                   '<span style="font-size:12px; color:#555;">' + details + '</span>' +
                   '</div>';
        }).join('');

        let html = '<div style="color:black;text-align:right;direction:rtl;min-width:180px;">' +
                   '<b style="color:#ff9100; font-size:14px;">Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¬ÙˆÙ„Ø©</b><hr>' +
                   studentRows +
                   '</div>';

        let namesArr = cluster.items.map(x => x.studentName || "");
        const mObj = addMarker(pos, "available", html, "#ff9100", cluster.items.length.toString(), namesArr);
        window.availableMarkers.push(mObj);
      });

      // Calculate Route if we have at least 2 points
      if (routeClusters.length >= 2) {
          calculateRoadRoute(routeClusters);
      }

      if (!bounds.isEmpty()) {
          map.fitBounds(bounds);
      }
    };

    // 6. ROUTE CALCULATION
    function calculateRoadRoute(clusters) {
      const startPoint = clusters.find(c => c.isStart);
      const endPoint = clusters.find(c => c.isFinal);
      if (!startPoint || !endPoint) return;

      const assistantAM = clusters.find(c => c.stopType === 'assistant' && c.timeShift === 'AM');
      const assistantPM = clusters.find(c => c.stopType === 'assistant' && c.timeShift === 'PM');

      const studentStops = clusters.filter(c => 
        c !== startPoint && c !== endPoint && c !== assistantAM && c !== assistantPM
      );

      // Virtual Start/End for calc
      const virtualOrigin = assistantAM || startPoint;
      const virtualDest = assistantPM || endPoint;

      // Prepare waypoints
      let requestWaypoints = studentStops.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: true }));

      // If no students, just link assistants
      if (studentStops.length === 0) {
        let waypoints = [];
        if (assistantAM) waypoints.push({ location: {lat: assistantAM.lat, lng: assistantAM.lng}, stopover: true });
        if (assistantPM) waypoints.push({ location: {lat: assistantPM.lat, lng: assistantPM.lng}, stopover: true });
        renderFinalRoute(startPoint, endPoint, waypoints);
        return;
      }

      directionsService.route({
        origin: { lat: virtualOrigin.lat, lng: virtualOrigin.lng },
        destination: { lat: virtualDest.lat, lng: virtualDest.lng },
        waypoints: requestWaypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: true, 
      }, (result, status) => {
        if (status === "OK") {
            const optimizedOrder = result.routes[0].waypoint_order;
            const sortedStudents = optimizedOrder.map(index => studentStops[index]);

            const finalWaypoints = [];
            
            if (assistantAM) finalWaypoints.push({ location: { lat: assistantAM.lat, lng: assistantAM.lng }, stopover: true });
            sortedStudents.forEach(s => finalWaypoints.push({ location: { lat: s.lat, lng: s.lng }, stopover: true }));
            if (assistantPM) finalWaypoints.push({ location: { lat: assistantPM.lat, lng: assistantPM.lng }, stopover: true });

            renderFinalRoute(startPoint, endPoint, finalWaypoints);
        }
      });
    }

    function renderFinalRoute(start, end, waypoints) {
      directionsService.route({
        origin: { lat: start.lat, lng: start.lng },
        destination: { lat: end.lat, lng: end.lng },
        waypoints: waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false, 
      }, (result, status) => {
        if (status === "OK") {
            directionsRenderer.setDirections(result);
            const route = result.routes[0];

            // Update markers with numbers
            waypoints.forEach((wp, index) => {
                const stopNum = (index + 1).toString();
                const markerObj = window.routeMarkers.find(m => 
                    Math.abs(m.lat - wp.location.lat) < 0.0001 && 
                    Math.abs(m.lng - wp.location.lng) < 0.0001
                );
                
                if (markerObj && markerObj.pin) {
                     // Check if it's an assistant marker to avoid overwriting "A"/"P"
                     const currentText = markerObj.pin.glyphText;
                     if (currentText !== "A" && currentText !== "P") {
                         markerObj.pin.glyphText = stopNum;
                     }
                }
            });

            // Update Summary Box
            let dist = 0, dur = 0;
            route.legs.forEach(leg => { dist += leg.distance.value; dur += leg.duration.value; });
            updateRouteSummary((dist / 1000).toFixed(1), Math.round(dur / 60));
        }
      });
    }
  </script>
</body>
</html>
