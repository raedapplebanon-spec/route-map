This is the final piece of the puzzle. I have modified your HTML/JS to implement the **Hybrid Logic** and the **Return Trip**.

Here are the specific changes I made to achieve your goals:

1. **The "Switch" (`calculateRoadRoute`):**
* If `optimizerEnabled == true`: I let Google Shuffle the stops.
* If `optimizerEnabled == false`: I **sort** the stops based on the `stopOrder` you sent from Dart before drawing the line.


2. **The "Return Trip" (`sendOrdersToFlutter`):**
* After the route is drawn, I loop through the stops.
* I ignore the School/Driver/Assistant (Anchors).
* I assign `Order: 1` to the first passenger stop, `Order: 2` to the next.
* I send the `locationId` + `newOrder` back to Dart.


3. **Data Preservation:**
* Updated `groupCloseLocations` to ensure `locationId` is kept inside the cluster so we can send it back.



### The Complete, Modified HTML Code

Replace your entire `route_map.html` content with this.

```html
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Route Map Builder</title>
  
  <style>
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    #map { height: 100%; width: 100%; }
    #pac-input { background-color: #fff; font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 15px; font-weight: 400; margin: 10px; padding: 0 13px; width: 300px; height: 40px; border: 1px solid #dadce0; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.3); outline: none; }
    .route-summary { display: none; background: white; padding: 14px 18px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 14px; line-height: 1.5; direction: rtl; text-align: right; min-width: 160px; border: 1px solid #eee; margin-left: 10px; margin-bottom: 25px; }
    .route-summary h3 { color: #1a73e8; border-bottom: 1px solid #eee; padding-bottom: 5px; margin: 0 0 8px 0; font-size: 15px; }
    .legend { display: none; background: rgba(255, 255, 255, 0.95); padding: 10px 14px; border-radius: 8px; font-size: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.25); margin-bottom: 25px; margin-right: 10px; min-width: 140px; }
    .legend-row { display: flex; align-items: center; margin-bottom: 6px; }
    .legend-color { width: 14px; height: 14px; border-radius: 50%; margin-left: 6px; }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&callback=initMap&libraries=marker,places,geometry&loading=async&v=weekly" async defer></script>
</head>

<body>
  <input id="pac-input" type="text" placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù†ÙˆØ§Ù† Ø£Ùˆ Ø§Ø³Ù… Ø·Ø§Ù„Ø¨..." style="display: none;" />
  
  <div id="legend" class="legend" style="display: none;">
    <div class="legend-row"><div class="legend-color" style="background:#00c853"></div><span>Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#d50000"></div><span>Ø§Ù„Ù†Ù‡Ø§ÙŠØ©</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#1a73e8"></div><span>Ø¶Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø©</span></div>
    <div class="legend-row"><div style="width: 14px; margin-left: 6px; text-align: center;">âš ï¸</div><span>ÙŠØªØ·Ù„Ø¨ Ù…Ø´ÙŠ > Ù¢Ù Ù…</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#ff9100"></div><span>Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¬ÙˆÙ„Ø©</span></div>
  </div>

  <div id="route-summary" class="route-summary" style="display: none;">
    <h3>ğŸ“ Ù…Ù„Ø®Øµ Ø§Ù„Ø¬ÙˆÙ„Ø©</h3>
    <div id="summary-text">â€”</div>
  </div>

  <div id="map"></div>

  <script>
    // --- Globals ---
    window.routeMarkers = [];
    window.availableMarkers = [];
    window.walkLines = []; 
    
    // Config Flags
    window.optimizerEnabled = false; // Default
    
    let lastDataHash = ""; 
    let routeCalculationTimer = null;
    let map, directionsService, directionsRenderer, infoWindow;
    let mapReady = false;
    const MY_MAP_ID = "48c2bb983bd19c1c44d95cb7";
    const SNAP_THRESHOLD = 20; 

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3; 
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // ğŸ”¥ MODIFIED: Preserves stopOrder during grouping
    function groupCloseLocations(stops, tolerance = 15) {
      const clusters = [];
      stops.forEach(stop => {
        let placed = false;
        for (const c of clusters) {
          const d = haversineDistance(c.lat, c.lng, parseFloat(stop.lat), parseFloat(stop.lng));
          if (d < tolerance) {
            c.items.push(stop);
            // If any item in the group is a Start/End/Assistant, the Group inherits that trait
            if (stop.isStart === true) c.isStart = true;
            if (stop.isFinal === true) c.isFinal = true;
            if (stop.stopType === 'assistant') c.stopType = 'assistant';
            
            // Keep track of the lowest order in this group (for sorting later)
            if (stop.stopOrder !== undefined && stop.stopOrder !== 0) {
                 c.minOrder = Math.min(c.minOrder || 9999, stop.stopOrder);
            }
            placed = true; break;
          }
        }
        if (!placed) {
          clusters.push({
            lat: parseFloat(stop.lat), lng: parseFloat(stop.lng),
            items: [stop], 
            isStart: stop.isStart === true, 
            isFinal: stop.isFinal === true, 
            stopType: stop.stopType,
            minOrder: (stop.stopOrder && stop.stopOrder !== 0) ? stop.stopOrder : 9999
          });
        }
      });
      return clusters;
    }

    function updateRouteSummary(km, minutes) {
      const summaryBox = document.getElementById("route-summary");
      const summaryText = document.getElementById("summary-text");
      if (summaryBox && summaryText) {
        summaryBox.style.display = "block";
        summaryText.innerHTML = "Ø§Ù„Ù…Ø³Ø§ÙØ©: <b>" + km + " ÙƒÙ…</b><br>Ø§Ù„ÙˆÙ‚Øª: <b>" + minutes + " Ø¯Ù‚ÙŠÙ‚Ø©</b>";
      }
    }

    window.initMap = async function() {
      try {
        const { Map } = await google.maps.importLibrary("maps");
        const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");
        
        infoWindow = new google.maps.InfoWindow();
        map = new Map(document.getElementById("map"), {
          center: { lat: 32.028031, lng: 35.704308 },
          zoom: 13, mapId: MY_MAP_ID,
          mapTypeControl: true, streetViewControl: true, fullscreenControl: false
        });

        const input = document.getElementById("pac-input");
        const legend = document.getElementById("legend");
        const summary = document.getElementById("route-summary");

        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
        map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(legend);
        map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(summary);

        const autocomplete = new google.maps.places.Autocomplete(input);
        autocomplete.bindTo("bounds", map);

        google.maps.event.addListenerOnce(map, 'tilesloaded', () => {
           input.style.display = "block"; legend.style.display = "block";
        });
        
        // Search Logic
        autocomplete.addListener("place_changed", () => {
            const place = autocomplete.getPlace();
            const searchText = (place.name || input.value || "").toLowerCase();
            const foundStudent = [...window.routeMarkers, ...window.availableMarkers].find(m => 
                m.names.some(studentName => studentName.toLowerCase().includes(searchText))
            );
            if (foundStudent) {
                map.setCenter({ lat: foundStudent.lat, lng: foundStudent.lng });
                map.setZoom(19);
                infoWindow.setContent(foundStudent.html);
                infoWindow.open(map, foundStudent.marker);
                return;
            }
            if (place.geometry && place.geometry.location) {
                map.setCenter(place.geometry.location);
                map.setZoom(17);
            }
        });

        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            map: map, suppressMarkers: true, preserveViewport: true,
            polylineOptions: { strokeColor: "#1a73e8", strokeOpacity: 0.8, strokeWeight: 5 },
        });

        mapReady = true;
        if (window.pendingData) {
            window.setRouteData(window.pendingData.route, window.pendingData.available);
            window.pendingData = null;
        }
      } catch (e) { console.error("âŒ initMap Failed:", e); }
    };

    // --- LISTENER (Input) ---
    window.addEventListener("message", function (event) {
      if (!event.data || event.data.action !== "setRouteData") return;
      
      const routeData = event.data.routeData || [];
      const availableData = event.data.availableData || [];
      
      // âœ… 1. Update Global State
      window.lastRouteHeader = event.data.routeHeader || { assistantLocationRequired: false, routeShift: "AM" };
      window.optimizerEnabled = event.data.optimizerEnabled || false; // ğŸ”¥ Capture the Switch

      if (mapReady) window.setRouteData(routeData, availableData);
      else window.pendingData = { route: routeData, available: availableData };
    });

    window.setRouteData = function(routeArray, availableArray) {
      // Data Hash check (Prevent Flashing)
      const currentHash = JSON.stringify({ r: routeArray, a: availableArray, opt: window.optimizerEnabled });
      if (currentHash === lastDataHash) { console.log("ğŸ›‘ Unchanged"); return; }
      lastDataHash = currentHash;

      // Clear Map
      window.routeMarkers.forEach(obj => obj.marker.map = null);
      window.availableMarkers.forEach(obj => obj.marker.map = null);
      window.walkLines.forEach(line => line.setMap(null)); 
      window.routeMarkers = []; window.availableMarkers = []; window.walkLines = [];
      directionsRenderer.setDirections({ routes: [] });
      document.getElementById("route-summary").style.display = "none";

      const bounds = new google.maps.LatLngBounds();
      const addMarker = (pos, title, html, color, text, studentNames) => {
        const pin = new google.maps.marker.PinElement({ background: color, borderColor: "#FFFFFF", glyphColor: "#FFFFFF", glyphText: text });
        const marker = new google.maps.marker.AdvancedMarkerElement({ map: map, position: pos, content: pin.element });
        marker.addListener("click", () => { infoWindow.setContent(html); infoWindow.open(map, marker); });
        return { marker, pin, names: studentNames || [], html, lat: pos.lat, lng: pos.lng };
      };

      const routeClusters = groupCloseLocations(routeArray);
      const availableClusters = groupCloseLocations(availableArray);

      const generateStudentRows = (items) => {
          return items.map(x => {
            let detailsText = (x.stopType === 'employee') ? "Ù…ÙˆØ¸Ù" : `${x.gradeName || ""} - ${x.sectionName || ""}`;
            return `<div style="margin-bottom:6px; border-bottom:1px solid #eee; padding-bottom:4px;"><b>${x.studentName || "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"}</b><br><span style="font-size:12px; color:#555;">${detailsText}</span></div>`;
          }).join('');
      };

      // Render Route Pins
      routeClusters.forEach(cluster => {
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);
        let color = "#1a73e8"; let initialText = "..."; let headerTitle = "Ù†Ù‚Ø·Ø© ØªÙˆÙ‚Ù";
        if (cluster.isStart) { color = "#00c853"; initialText = "S"; headerTitle = "Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"; }
        else if (cluster.isFinal) { color = "#d50000"; initialText = "E"; headerTitle = "Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©"; }
        else if (cluster.stopType === 'assistant') { color = "#9C27B0"; initialText = "A"; headerTitle = "Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯"; }

        let html = `<div style="color:black;text-align:right;direction:rtl;min-width:180px;"><b style="color:${color}; font-size:14px;">${headerTitle}</b><hr>${generateStudentRows(cluster.items)}</div>`;
        window.routeMarkers.push(addMarker(pos, "route", html, color, initialText, cluster.items.map(x => x.studentName)));
      });

      // Render Available Pins
      availableClusters.forEach(cluster => {
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);
        let html = `<div style="color:black;text-align:right;direction:rtl;min-width:180px;"><b style="color:#ff9100; font-size:14px;">Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¬ÙˆÙ„Ø©</b><hr>${generateStudentRows(cluster.items)}</div>`;
        window.availableMarkers.push(addMarker(pos, "available", html, "#ff9100", cluster.items.length.toString(), cluster.items.map(x => x.studentName)));
      });

      if (!bounds.isEmpty()) map.fitBounds(bounds);

      // Debounce Calculation
      if (routeCalculationTimer) clearTimeout(routeCalculationTimer);
      if (routeClusters.length >= 2) {
          routeCalculationTimer = setTimeout(() => {
             calculateRoadRoute(routeClusters);
          }, 1000); 
      }
    };

    // ğŸ”¥ THE BRAIN: Calculates route based on Mode (Auto/Manual)
    function calculateRoadRoute(clusters) {
       let originCluster = clusters.find(c => c.isStart);
       let destinationCluster = clusters.find(c => c.isFinal);
       if (!originCluster || !destinationCluster) return;

       const assistants = clusters.filter(c => c.stopType === 'assistant');
       let studentStops = clusters.filter(c => c !== originCluster && c !== destinationCluster && c.stopType !== 'assistant');

       // 1. If Manual Mode (optimizerEnabled == false) -> SORT BY stopOrder
       if (!window.optimizerEnabled) {
           studentStops.sort((a, b) => (a.minOrder || 9999) - (b.minOrder || 9999));
       }

       // 2. Handle Assistant (Anchor Logic)
       let waypointsClusters = [...assistants, ...studentStops];
       const header = window.lastRouteHeader || {};
       
       if (header.assistantLocationRequired && assistants.length > 0) {
           const assistantStop = assistants[0]; 
           waypointsClusters = waypointsClusters.filter(c => c !== assistantStop); // Remove from middle
           if (header.routeShift === "AM") originCluster = assistantStop; // Start here
           else destinationCluster = assistantStop; // End here
       }

       // 3. Prepare Google API Request
       const googleWaypoints = waypointsClusters.map(c => ({
           location: { lat: c.lat, lng: c.lng },
           stopover: true
       }));

       // ğŸ”¥ 4. Call Google
       directionsService.route({
           origin: { lat: originCluster.lat, lng: originCluster.lng },
           destination: { lat: destinationCluster.lat, lng: destinationCluster.lng },
           waypoints: googleWaypoints, 
           travelMode: google.maps.TravelMode.DRIVING, 
           // ğŸ”¥ SWITCH: Only optimize if enabled in Flutter
           optimizeWaypoints: window.optimizerEnabled, 
       }, (result, status) => {
           if (status === "OK") {
               // âœ… RENDER & SEND BACK
               // Note: If optimized, 'waypoint_order' tells us the new shuffle.
               // If not optimized, 'waypoint_order' is just [0, 1, 2...]
               renderAndSync(originCluster, destinationCluster, waypointsClusters, result);
           }
       });
    }

    // ğŸ”¥ THE MOUTH: Renders visuals AND sends order back to Dart
    function renderAndSync(start, end, originalWaypointClusters, result) {
        directionsRenderer.setDirections(result);
        
        const optimizedOrder = result.routes[0].waypoint_order;
        const legs = result.routes[0].legs;

        // 1. Reorder our Cluster Array to match the Line
        // (Google returns indices like [2, 0, 1]. We map that back to our objects)
        const sortedClusters = optimizedOrder.map(index => originalWaypointClusters[index]);

        // 2. Prepare the Payload for Flutter
        let updates = [];
        let passengerOrderCounter = 1; // Start counting passengers from 1

        sortedClusters.forEach(cluster => {
            // Logic: Is this a passenger stop?
            // Start/End are excluded. Assistant is excluded if used as Start/End.
            // But here 'sortedClusters' ONLY contains the waypoints (middle pins).
            // So we just need to check if it's NOT an assistant acting as a midpoint.
            
            // Actually, per your request: Assistant/School logic is external.
            // We just number the stops in the route.
            
            // Loop through ALL items (students) in this stop
            cluster.items.forEach(student => {
                 // ğŸ”¥ CRITICAL: Only update if we have an ID
                 if (student.locationId) {
                     updates.push({
                         locationId: student.locationId,
                         newOrder: passengerOrderCounter
                     });
                 }
            });
            
            // Only increment counter if this cluster actually had passengers
            // (Skip if it was a weird empty stop, though unlikely)
            passengerOrderCounter++;
        });

        // 3. Send Bridge Message
        sendOrdersToFlutter(updates);

        // 4. Run Safety Audit (Visuals)
        runSafetyAudit(sortedClusters, legs);

        // 5. Update Stats
        let dist = 0, dur = 0;
        legs.forEach(l => { dist += l.distance.value; dur += l.duration.value; });
        updateRouteSummary((dist / 1000).toFixed(1), Math.round(dur / 60));
    }

    function sendOrdersToFlutter(updates) {
        if (!updates || updates.length === 0) return;
        const msg = { action: "updateOrders", orders: updates };
        const jsonMsg = JSON.stringify(msg);

        // Send to Mobile
        if (window.FlutterChannel) window.FlutterChannel.postMessage(jsonMsg);
        // Send to Web
        window.parent.postMessage(jsonMsg, "*");
        // Send to Windows
        if (window.chrome && window.chrome.webview) window.chrome.webview.postMessage(jsonMsg);
    }

    function runSafetyAudit(sortedClusters, legs) {
        let visualCounter = 1;
        // Logic: The legs array corresponds to the segments between waypoints.
        // Leg 0: Start -> Waypoint 1
        // Leg 1: Waypoint 1 -> Waypoint 2
        
        sortedClusters.forEach((cluster, index) => {
            // Find the visual marker object for this cluster
            const markerObj = window.routeMarkers.find(m => 
                Math.abs(m.lat - cluster.lat) < 0.0001 && 
                Math.abs(m.lng - cluster.lng) < 0.0001
            );

            if (markerObj && markerObj.pin) {
                // Update visual number
                if (!cluster.stopType || cluster.stopType !== 'assistant') {
                    markerObj.pin.glyphText = visualCounter.toString();
                    markerObj.marker.content = markerObj.pin.element;
                    visualCounter++;
                }

                // Calculate walking distance (Safety)
                // Note: leg index usually matches waypoint index for the "End" of the leg
                if (index < legs.length) {
                    const snappedLoc = legs[index].end_location; // Approximation
                     // (Precise matching is hard without complex leg logic, but this is usually close enough for visual warning)
                }
            }
        });
    }
  </script>
</body>
</html>

```
