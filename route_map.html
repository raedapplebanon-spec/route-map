<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Route Map Builder</title>
  
  <style>
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    #map { height: 100%; width: 100%; }
    #pac-input { background-color: #fff; font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 15px; font-weight: 400; margin: 10px; padding: 0 13px; width: 300px; height: 40px; border: 1px solid #dadce0; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.3); outline: none; }
    .route-summary { display: none; background: white; padding: 14px 18px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 14px; line-height: 1.5; direction: rtl; text-align: right; min-width: 160px; border: 1px solid #eee; margin-left: 10px; margin-bottom: 25px; }
    .route-summary h3 { color: #1a73e8; border-bottom: 1px solid #eee; padding-bottom: 5px; margin: 0 0 8px 0; font-size: 15px; }
    .legend { display: none; background: rgba(255, 255, 255, 0.95); padding: 10px 14px; border-radius: 8px; font-size: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.25); margin-bottom: 25px; margin-right: 10px; min-width: 140px; }
    .legend-row { display: flex; align-items: center; margin-bottom: 6px; }
    .legend-color { width: 14px; height: 14px; border-radius: 50%; margin-left: 6px; }
    .warn-badge { background: #d32f2f; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 5px; }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&callback=initMap&libraries=marker,places,geometry&loading=async&v=weekly" async defer></script>
</head>

<body>
  <input id="pac-input" type="text" placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù†ÙˆØ§Ù† Ø£Ùˆ Ø§Ø³Ù… Ø·Ø§Ù„Ø¨..." style="display: none;" />
  
  <div id="legend" class="legend" style="display: none;">
    <div class="legend-row"><div class="legend-color" style="background:#00c853"></div><span>Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#d50000"></div><span>Ø§Ù„Ù†Ù‡Ø§ÙŠØ©</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#1a73e8"></div><span>Ø¶Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø©</span></div>
    <div class="legend-row"><div style="width: 14px; margin-left: 6px; text-align: center;">âš ï¸</div><span>ÙŠØªØ·Ù„Ø¨ Ù…Ø´ÙŠ > Ù£Ù Ù…</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#ff9100"></div><span>Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¬ÙˆÙ„Ø©</span></div>
  </div>

  <div id="route-summary" class="route-summary" style="display: none;">
    <h3>ğŸ“ Ù…Ù„Ø®Øµ Ø§Ù„Ø¬ÙˆÙ„Ø©</h3>
    <div id="summary-text">â€”</div>
  </div>

  <div id="map"></div>

  <script>
    // --- Globals ---
    window.routeMarkers = [];
    window.availableMarkers = [];
    window.walkLines = []; 
    
    // ğŸ”¥ NEW: Check to prevent flashing
    let lastDataHash = ""; 

    let map, directionsService, directionsRenderer, infoWindow;
    let mapReady = false;
    const MY_MAP_ID = "48c2bb983bd19c1c44d95cb7";
    
    // ğŸ”¥ CONFIG: Warning Threshold (Meters)
    const SNAP_THRESHOLD = 30; 

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3; 
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function groupCloseLocations(stops, tolerance = 15) {
      const clusters = [];
      stops.forEach(stop => {
        let placed = false;
        for (const c of clusters) {
          const d = haversineDistance(c.lat, c.lng, parseFloat(stop.lat), parseFloat(stop.lng));
          if (d < tolerance) {
            c.items.push(stop);
            if (stop.isStart === true) c.isStart = true;
            if (stop.isFinal === true) c.isFinal = true;
            if (stop.stopType === 'assistant') c.stopType = 'assistant';
            placed = true; break;
          }
        }
        if (!placed) {
          clusters.push({
            lat: parseFloat(stop.lat), lng: parseFloat(stop.lng),
            items: [stop], isStart: stop.isStart === true, isFinal: stop.isFinal === true, stopType: stop.stopType
          });
        }
      });
      return clusters;
    }

    function updateRouteSummary(km, minutes) {
      const summaryBox = document.getElementById("route-summary");
      const summaryText = document.getElementById("summary-text");
      if (summaryBox && summaryText) {
        summaryBox.style.display = "block";
        summaryText.innerHTML = "Ø§Ù„Ù…Ø³Ø§ÙØ©: <b>" + km + " ÙƒÙ…</b><br>Ø§Ù„ÙˆÙ‚Øª: <b>" + minutes + " Ø¯Ù‚ÙŠÙ‚Ø©</b>";
      }
    }

    window.initMap = async function() {
      try {
        const { Map } = await google.maps.importLibrary("maps");
        const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");
        const { Places } = await google.maps.importLibrary("places");

        infoWindow = new google.maps.InfoWindow();

        map = new Map(document.getElementById("map"), {
          center: { lat: 32.028031, lng: 35.704308 },
          zoom: 13,
          mapId: MY_MAP_ID,
          mapTypeControl: true, streetViewControl: true, fullscreenControl: false
        });

        const input = document.getElementById("pac-input");
        const legend = document.getElementById("legend");
        const summary = document.getElementById("route-summary");

        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
        map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(legend);
        map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(summary);

        const autocomplete = new google.maps.places.Autocomplete(input);
        autocomplete.bindTo("bounds", map);

        google.maps.event.addListenerOnce(map, 'tilesloaded', () => {
           input.style.display = "block"; legend.style.display = "block";
        });

        autocomplete.addListener("place_changed", () => {
            const place = autocomplete.getPlace();
            const searchText = (place.name || input.value || "").toLowerCase();
            const foundStudent = [...window.routeMarkers, ...window.availableMarkers].find(m => 
                m.names.some(studentName => studentName.toLowerCase().includes(searchText))
            );
            if (foundStudent) {
                map.setCenter({ lat: foundStudent.lat, lng: foundStudent.lng });
                map.setZoom(19);
                infoWindow.setContent(foundStudent.html);
                infoWindow.open(map, foundStudent.marker);
                return;
            }
            if (place.geometry && place.geometry.location) {
                map.setCenter(place.geometry.location);
                map.setZoom(17);
            }
        });

        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            map: map, suppressMarkers: true, preserveViewport: true,
            polylineOptions: { strokeColor: "#1a73e8", strokeOpacity: 0.8, strokeWeight: 5 },
        });

        mapReady = true;
        console.log("âœ… Route Map Initialized");

        if (window.pendingData) {
            window.setRouteData(window.pendingData.route, window.pendingData.available);
            window.pendingData = null;
        }
      } catch (e) { console.error("âŒ initMap Failed:", e); }
    };

    window.addEventListener("message", function (event) {
      if (!event.data || event.data.action !== "setRouteData") return;
      const routeData = event.data.routeData || [];
      const availableData = event.data.availableData || [];
      if (mapReady) window.setRouteData(routeData, availableData);
      else window.pendingData = { route: routeData, available: availableData };
    });

    window.setRouteData = function(routeArray, availableArray) {
      // ğŸ”¥ FIX FLASHING: Check if data is exactly the same as before
      const currentHash = JSON.stringify({ r: routeArray, a: availableArray });
      if (currentHash === lastDataHash) {
          console.log("ğŸ›‘ Data unchanged, skipping redraw.");
          return;
      }
      lastDataHash = currentHash;

      // Clear all
      window.routeMarkers.forEach(obj => obj.marker.map = null);
      window.availableMarkers.forEach(obj => obj.marker.map = null);
      window.walkLines.forEach(line => line.setMap(null)); 
      
      window.routeMarkers = [];
      window.availableMarkers = [];
      window.walkLines = [];
      
      directionsRenderer.setDirections({ routes: [] });
      document.getElementById("route-summary").style.display = "none";

      const bounds = new google.maps.LatLngBounds();

      const addMarker = (pos, title, html, color, text, studentNames) => {
        const pin = new google.maps.marker.PinElement({ background: color, borderColor: "#FFFFFF", glyphColor: "#FFFFFF", glyphText: text });
        const marker = new google.maps.marker.AdvancedMarkerElement({ map: map, position: pos, content: pin.element });
        marker.addListener("click", () => { infoWindow.setContent(html); infoWindow.open(map, marker); });
        return { marker, pin, names: studentNames || [], html, lat: pos.lat, lng: pos.lng };
      };

      const routeClusters = groupCloseLocations(routeArray);
      const availableClusters = groupCloseLocations(availableArray);

      // Helper to generate Student Rows with Grade/Section
      const generateStudentRows = (items) => {
          return items.map(x => `
            <div style="margin-bottom:6px; border-bottom:1px solid #eee; padding-bottom:4px;">
                <b>${x.studentName || "Ø·Ø§Ù„Ø¨"}</b><br>
                <span style="font-size:12px; color:#555;">${x.gradeName || ""} - ${x.sectionName || ""}</span>
            </div>
          `).join('');
      };

      // 1. Render Route Markers
      routeClusters.forEach(cluster => {
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);
        let color = "#1a73e8"; let initialText = "..."; let headerTitle = "Ù†Ù‚Ø·Ø© ØªÙˆÙ‚Ù";
        if (cluster.isStart) { color = "#00c853"; initialText = "S"; headerTitle = "Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"; }
        else if (cluster.isFinal) { color = "#d50000"; initialText = "E"; headerTitle = "Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©"; }
        else if (cluster.stopType === 'assistant') { color = "#9C27B0"; initialText = "A"; headerTitle = "Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯"; }

        // âœ… FIXED: Using generateStudentRows for consistent formatting
        let studentRows = generateStudentRows(cluster.items);
        let html = `<div style="color:black;text-align:right;direction:rtl;min-width:180px;"><b style="color:${color}; font-size:14px;">${headerTitle}</b><hr>${studentRows}</div>`;
        let namesArr = cluster.items.map(x => x.studentName || "");
        
        window.routeMarkers.push(addMarker(pos, "route", html, color, initialText, namesArr));
      });

      // 2. Render Available Markers
      availableClusters.forEach(cluster => {
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);
        
        // âœ… FIXED: Now showing Name, Grade, Section for Orange Markers too
        let studentRows = generateStudentRows(cluster.items);
        let html = `<div style="color:black;text-align:right;direction:rtl;min-width:180px;"><b style="color:#ff9100; font-size:14px;">Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¬ÙˆÙ„Ø©</b><hr>${studentRows}</div>`;
        let namesArr = cluster.items.map(x => x.studentName || "");

        window.availableMarkers.push(addMarker(pos, "available", html, "#ff9100", cluster.items.length.toString(), namesArr));
      });

      if (routeClusters.length >= 2) calculateRoadRoute(routeClusters);
      if (!bounds.isEmpty()) map.fitBounds(bounds);
    };

    function calculateRoadRoute(clusters) {
       const startPoint = clusters.find(c => c.isStart);
       const endPoint = clusters.find(c => c.isFinal);
       if (!startPoint || !endPoint) return;

       const assistants = clusters.filter(c => c.stopType === 'assistant');
       const studentStops = clusters.filter(c => c !== startPoint && c !== endPoint && c.stopType !== 'assistant');
       
       let waypoints = [
           ...assistants.map(a => ({ location: {lat: a.lat, lng: a.lng}, stopover: true })),
           ...studentStops.map(s => ({ location: {lat: s.lat, lng: s.lng}, stopover: true }))
       ];

       directionsService.route({
           origin: { lat: startPoint.lat, lng: startPoint.lng },
           destination: { lat: endPoint.lat, lng: endPoint.lng },
           waypoints: waypoints, travelMode: google.maps.TravelMode.DRIVING, optimizeWaypoints: true,
       }, (result, status) => {
           if (status === "OK") {
               const optimizedOrder = result.routes[0].waypoint_order;
               const finalWaypoints = optimizedOrder.map(index => waypoints[index]);
               // Render Final Route AND Check Accessibility
               renderFinalRoute(startPoint, endPoint, finalWaypoints);
           }
       });
    }

    function renderFinalRoute(start, end, waypoints) {
      directionsService.route({
        origin: { lat: start.lat, lng: start.lng },
        destination: { lat: end.lat, lng: end.lng },
        waypoints: waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false,
      }, (result, status) => {
        if (status === "OK") {
            directionsRenderer.setDirections(result);
            const legs = result.routes[0].legs; 
            
            let visualCounter = 1;

            waypoints.forEach((wp, index) => {
                const legIndex = index; 
                if (legIndex >= legs.length) return;

                const snappedLoc = legs[legIndex].end_location; // Google's safe road spot
                const originalLoc = wp.location; // Original House Pin

                // Find the Marker for this location
                const markerObj = window.routeMarkers.find(m => 
                    Math.abs(m.lat - originalLoc.lat) < 0.0001 && 
                    Math.abs(m.lng - originalLoc.lng) < 0.0001
                );

                if (markerObj && markerObj.pin) {
                    // 1. UPDATE NUMBER
                    const isAssistant = markerObj.html.includes("Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯");
                    if (!isAssistant) {
                        markerObj.pin.glyphText = visualCounter.toString();
                        visualCounter++;
                    }

                    // 2. ğŸ”¥ CHECK ACCESSIBILITY (The Magic)
                    const distance = google.maps.geometry.spherical.computeDistanceBetween(
                        new google.maps.LatLng(originalLoc.lat, originalLoc.lng),
                        snappedLoc
                    );

                    if (distance > SNAP_THRESHOLD) {
                        console.warn(`âš ï¸ Warning: Stop ${visualCounter-1} is ${Math.round(distance)}m from the road.`);
                        
                        // ğŸ”¥ UPDATED: RED STYLE + WARNING ICON
                        markerObj.pin.background = "#d32f2f"; // Red
                        markerObj.pin.borderColor = "#b71c1c";
                        markerObj.pin.glyphText = "âš ï¸"; 
                        markerObj.pin.glyphColor = "white";
                        
                        // B. Draw Dotted Walk Line
                        const walkLine = new google.maps.Polyline({
                            path: [{lat: originalLoc.lat, lng: originalLoc.lng}, snappedLoc],
                            geodesic: true,
                            strokeColor: "#d32f2f",
                            strokeOpacity: 0,
                            strokeWeight: 2,
                            icons: [{ icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 2 }, offset: '0', repeat: '10px' }],
                            map: map
                        });
                        window.walkLines.push(walkLine);

                        // C. Update Info Window
                        let warningHtml = `<div style="background:#ffebee; color:#c62828; padding:5px; border-radius:4px; margin-bottom:5px; font-size:12px; border:1px solid #ef9a9a;">âš ï¸ <b>ØªÙ†Ø¨ÙŠÙ‡:</b> Ø§Ù„Ø­Ø§ÙÙ„Ø© ØªØªÙˆÙ‚Ù Ø¹Ù„Ù‰ Ø¨Ø¹Ø¯ ${Math.round(distance)}Ù…</div>`;
                        markerObj.html = markerObj.html.replace('<hr>', `<hr>${warningHtml}`);
                    }
                }
            });

            // Update Summary
            let dist = 0, dur = 0;
            legs.forEach(l => { dist += l.distance.value; dur += l.duration.value; });
            updateRouteSummary((dist / 1000).toFixed(1), Math.round(dur / 60));
        }
      });
    }
  </script>
</body>
</html>



