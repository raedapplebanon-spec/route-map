<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>All Routes Admin Map</title>
  <style>
    /* ‚úÖ 1. Layout Settings */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: "Segoe UI", Tahoma, sans-serif;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    /* ‚úÖ 2. Search Box */
    #pac-input {
      display: none; 
      background-color: #fff;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      font-size: 14px;
      font-weight: 500;
      margin-top: 10px;
      margin-left: 10px;
      padding: 0 12px;
      width: 280px;
      height: 40px;
      border-radius: 8px;
      border: 1px solid #ddd;
      box-shadow: 0 4px 6px rgba(0,0,0,0.15);
      outline: none;
      direction: rtl;
    }

    /* ‚úÖ 3. Legend */
    #legend {
      display: none; 
      background: rgba(255, 255, 255, 0.95);
      margin: 12px;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      max-height: 300px;
      overflow-y: auto;
      direction: rtl;
      min-width: 160px;
      border: 1px solid #eee;
    }

    .legend-header {
      font-weight: bold;
      margin-bottom: 8px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 6px;
      color: #333;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      padding: 2px 0;
    }

    .color-box {
      width: 14px;
      height: 14px;
      margin-left: 8px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.1);
    }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&libraries=places,marker&callback=initMap&loading=async&v=weekly" async defer></script>
</head>
<body>

  <input id="pac-input" class="controls" type="text" placeholder="ÿ®ÿ≠ÿ´ ÿπŸÜ ÿ∑ÿßŸÑÿ® ÿ£Ÿà ŸÖŸàŸÇÿπ..." />
  <div id="legend"></div>
  
  <div id="map"></div>

  <script>
    let map, infoWindow;
    let mapReady = false;
    
    // Store active objects
    window.activeRoutes = []; 
    window.availableMarkers = [];

    const COLORS = [
      "#D50000", "#2962FF", "#00C853", "#FF6D00", "#AA00FF", 
      "#00B8D4", "#C51162", "#3E2723", "#2E7D32", "#304FFE"
    ];

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function groupCloseLocations(stops, tolerance = 15) {
      const clusters = [];
      stops.forEach(stop => {
        let placed = false;
        
        // üî• NORMALIZE DATA: Handle stopType (camelCase) or stop_type (snake_case)
        const rawType = stop.stopType || stop.stop_type || "";
        const type = rawType.toLowerCase().trim();
        const shift = (stop.timeShift || "").toUpperCase().trim();

        // Fix Lat/Lng parsing
        const sLat = parseFloat(stop.lat);
        const sLng = parseFloat(stop.lng);

        for (const c of clusters) {
          const d = haversineDistance(c.lat, c.lng, sLat, sLng);
          if (d < tolerance) {
            c.items.push(stop);
            // Update cluster properties if this specific stop has Start/Final flags
            if (stop.isStart === true || stop.is_start_stop === true) c.isStart = true;
            if (stop.isFinal === true || stop.is_end_stop === true) c.isFinal = true;
            
            // If any item in cluster is assistant, mark cluster as assistant
            if (type === 'assistant') {
              c.stopType = 'assistant';
              if (shift) c.timeShift = shift;
            }
            c.hideMarker = c.hideMarker && (stop.hideMarker === true || stop.hideMarker === 'true');
            placed = true;
            break;
          }
        }
        if (!placed) {
          clusters.push({
            lat: sLat,
            lng: sLng,
            items: [stop],
            isStart: (stop.isStart === true || stop.is_start_stop === true),
            isFinal: (stop.isFinal === true || stop.is_end_stop === true),
            stopType: type, // This will be 'employee', 'student', or 'assistant'
            timeShift: shift,
            hideMarker: (stop.hideMarker === true || stop.hideMarker === 'true')
          });
        }
      });
      return clusters;
    }

    // --- INIT MAP ---
    window.initMap = async function() {
      const { Map } = await google.maps.importLibrary("maps");
      const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");

      infoWindow = new google.maps.InfoWindow();

      map = new Map(document.getElementById("map"), {
        center: { lat: 32.028031, lng: 35.704308 },
        zoom: 13,
        mapTypeControl: true,
        streetViewControl: false,
        fullscreenControl: false,
        mapId: "48c2bb983bd19c1c44d95cb7" 
      });

      const input = document.getElementById("pac-input");
      const legend = document.getElementById("legend");
      
      const autocomplete = new google.maps.places.Autocomplete(input);
      autocomplete.bindTo("bounds", map);
      
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
      map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(legend);

      google.maps.event.addListenerOnce(map, 'tilesloaded', () => {
         input.style.display = "block"; 
      });

      mapReady = true;
      window.addEventListener("message", handleMessage);
      
      console.log("‚úÖ Map Initialized");
    };

    function handleMessage(event) {
      if (!event.data) return;
      let data = event.data;
      if (typeof data === 'string') {
        try { data = JSON.parse(data); } catch(e) { return; }
      }
      
      if (data.action === "setRouteData") {
        if (data.routesGrouped && data.routesGrouped.length > 0) {
            renderAllRoutes(data.routesGrouped, data.availableData);
        } else if (data.routeData && data.routeData.length > 0) {
            const fakeGroup = [{ routeId: "default", points: data.routeData }];
            renderAllRoutes(fakeGroup, data.availableData);
        } else {
            renderAllRoutes([], data.availableData);
        }
      }
    }

    // --- MAIN RENDERER ---
    async function renderAllRoutes(groupedRoutes, availableData) {
      if (!mapReady) return;

      // 1. Clear Map
      window.activeRoutes.forEach(r => {
        r.renderer.setMap(null);
        r.markers.forEach(m => m.map = null);
      });
      window.activeRoutes = [];
      window.availableMarkers.forEach(m => m.map = null);
      window.availableMarkers = [];

      const legend = document.getElementById("legend");
      const count = groupedRoutes ? groupedRoutes.length : 0;
      const bounds = new google.maps.LatLngBounds();

      if (count > 0) {
        legend.innerHTML = `<div class="legend-header">ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ: ${count} ÿ¨ŸàŸÑÿßÿ™</div>`;
        legend.style.display = "block";
        
        let i = 0;
        for (const group of groupedRoutes) {
          const color = COLORS[i % COLORS.length];
          const routeId = group.routeId || "Unknown";
          const points = group.points;

          legend.innerHTML += `
            <div class="legend-item">
              <div class="color-box" style="background:${color}"></div>
              <span>ÿ¨ŸàŸÑÿ©: ${routeId}</span>
            </div>
          `;

          await processSingleRoute(routeId, points, color, bounds);
          i++;
        }
      } else {
        legend.style.display = "none";
      }

      // 3. Draw Available
      if (availableData && availableData.length > 0) {
        renderAvailableStudents(availableData, bounds);
      }

      if (!bounds.isEmpty()) {
        map.fitBounds(bounds);
      }
    }

    // --- SINGLE ROUTE PROCESSOR ---
    // --- SINGLE ROUTE PROCESSOR (FIXED) ---
    function processSingleRoute(routeId, rawPoints, color, bounds) {
      return new Promise((resolve) => {
        
        const clusters = groupCloseLocations(rawPoints);
        
        const dService = new google.maps.DirectionsService();
        const dRenderer = new google.maps.DirectionsRenderer({
          map: map,
          suppressMarkers: true,
          preserveViewport: true,
          polylineOptions: { strokeColor: color, strokeOpacity: 0.8, strokeWeight: 6 }
        });

        const routeObj = { renderer: dRenderer, markers: [], routeId: routeId };
        window.activeRoutes.push(routeObj);

        // 1. Draw Markers (Visuals)
        clusters.forEach(cluster => {
          if (cluster.hideMarker) return;
          const pos = { lat: cluster.lat, lng: cluster.lng };
          bounds.extend(pos);

          let pinText = "..."; 
          let pinHeader = "ŸÜŸÇÿ∑ÿ© ÿ™ŸàŸÇŸÅ";
          let borderColor = color;

          // üî• VISUAL PRIORITY: Check Assistant FIRST so they get "A" even if they are the Start
          if (cluster.stopType === 'assistant') {
            pinText = cluster.timeShift === 'AM' ? "A" : "P";
            pinHeader = "ÿßŸÑŸÖÿ≥ÿßÿπÿØ (" + cluster.timeShift + ")";
            borderColor = "#000"; // Black border for VIPs
          } 
          else if (cluster.isStart) {
            pinText = "S"; pinHeader = "ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ®ÿØÿßŸäÿ©"; borderColor = "#000";
          } 
          else if (cluster.isFinal) {
            pinText = "E"; pinHeader = "ŸÜŸÇÿ∑ÿ© ÿßŸÑŸÜŸáÿßŸäÿ©"; borderColor = "#000";
          }

          const html = buildInfoWindowHtml(cluster, pinHeader, color);
          const marker = createAdvancedMarker(pos, color, pinText, html, borderColor);
          routeObj.markers.push(marker);
        });

        // 2. Routing Logic (Simplified)
        const startPoint = clusters.find(c => c.isStart);
        const endPoint = clusters.find(c => c.isFinal);

        // If missing anchors, we can't route
        if (!startPoint || !endPoint) {
          resolve(); 
          return;
        }

        // üî• LOGIC FIX: Just grab everything BETWEEN Start and End
        // We do NOT look for assistants specifically anymore. Dart handled that.
        const middleStops = clusters.filter(c => c !== startPoint && c !== endPoint);

        if (middleStops.length > 0) {
          const waypointsForAPI = middleStops.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: true }));
          
          dService.route({
            origin: { lat: startPoint.lat, lng: startPoint.lng },
            destination: { lat: endPoint.lat, lng: endPoint.lng },
            waypoints: waypointsForAPI,
            travelMode: google.maps.TravelMode.DRIVING,
            optimizeWaypoints: true, // Let Google Shuffle the middle
          }, (result, status) => {
            if (status === "OK") {
              // Get sorted sequence of the MIDDLE stops
              const optimizedOrder = result.routes[0].waypoint_order;
              const sortedMiddleStops = optimizedOrder.map(index => middleStops[index]);

              // Draw Line & Number Pins
              drawFinalPolyline(dService, dRenderer, startPoint, endPoint, sortedMiddleStops, routeObj, resolve);
            } else {
              console.error("Routing Failed:", status);
              resolve();
            }
          });
        } else {
          // No middle stops, just Start -> End
          drawFinalPolyline(dService, dRenderer, startPoint, endPoint, [], routeObj, resolve);
        }
      });
    }

    // --- DRAWER (FIXED) ---
    function drawFinalPolyline(service, renderer, start, end, sortedMiddleStops, routeObj, onComplete) {
      
      // üî• FIX: Waypoints must ONLY be the middle stops. 
      // Do NOT add Start/End here, or Google visits them twice.
      const waypoints = sortedMiddleStops.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: true }));

      service.route({
        origin: { lat: start.lat, lng: start.lng },
        destination: { lat: end.lat, lng: end.lng },
        waypoints: waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false, // Order is already sorted above
      }, (result, status) => {
        if (status === "OK") {
          renderer.setDirections(result);

          // Numbering Logic
          let counter = 1;
          sortedMiddleStops.forEach((stopCluster) => {
             // We only number the MIDDLE stops (Students/Employees)
             // Assistants/Start/End already have letters (A, S, E)
             
             // Safety check: Don't number the assistant if they ended up in the middle (unlikely now)
             const isAssistant = stopCluster.stopType === 'assistant';
             
             if (!isAssistant) {
                 const m = routeObj.markers.find(mark => 
                   Math.abs(mark.position.lat - stopCluster.lat) < 0.0001 && 
                   Math.abs(mark.position.lng - stopCluster.lng) < 0.0001
                 );
                 
                 if (m && m.content) {
                     // Update the Pin Text to 1, 2, 3...
                     m.content.glyphText = counter.toString();
                     counter++;
                 }
             }
          });
        }
        onComplete();
      });
    }
    function drawFinalPolyline(service, renderer, start, end, orderedStops, routeObj, onComplete) {
      // Prepare waypoints for the drawing call (excluding start/end)
      const waypoints = orderedStops.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: true }));

      service.route({
        origin: { lat: start.lat, lng: start.lng },
        destination: { lat: end.lat, lng: end.lng },
        waypoints: waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false, // Order is fixed now
      }, (result, status) => {
        if (status === "OK") {
          renderer.setDirections(result);

          let counter = 1;
          orderedStops.forEach((stopCluster) => {
             // Only number students AND employees (skip Assistants)
             const isAssistant = stopCluster.stopType === 'assistant';
             
             if (!isAssistant) {
                 const m = routeObj.markers.find(mark => 
                   Math.abs(mark.position.lat - stopCluster.lat) < 0.0001 && 
                   Math.abs(mark.position.lng - stopCluster.lng) < 0.0001
                 );
                 
                 if (m && m.content) {
                     // Update Glyph Text to Number
                     // Since AdvancedMarkerElement.content is a DOM element (pin.element), 
                     // we technically need to update the PinElement itself.
                     // A safe hack for current Maps API versions:
                     m.content.glyphText = counter.toString();
                     counter++;
                 }
             }
          });
        }
        onComplete();
      });
    }

    function renderAvailableStudents(points, bounds) {
      const clusters = groupCloseLocations(points);
      const color = "#9E9E9E";
      clusters.forEach(cluster => {
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);
        const html = buildInfoWindowHtml(cluster, "ÿÆÿßÿ±ÿ¨ ÿßŸÑÿ¨ŸàŸÑÿ©", color);
        const marker = createAdvancedMarker(pos, color, cluster.items.length.toString(), html, "#333");
        window.availableMarkers.push(marker);
      });
    }

    function createAdvancedMarker(pos, color, text, html, borderColor = "#FFF") {
      const pin = new google.maps.marker.PinElement({
        background: color,
        borderColor: borderColor,
        glyphColor: "#FFFFFF",
        glyphText: text 
      });
      const marker = new google.maps.marker.AdvancedMarkerElement({
        map: map,
        position: pos,
        content: pin.element,
        gmpClickable: true
      });
      
      marker.addListener("click", () => {
        infoWindow.setContent(html);
        infoWindow.open(map, marker);
      });
      return marker;
    }

    // üî• UPDATED: Now handles Employee data and new JSON keys
    function buildInfoWindowHtml(cluster, title, color) {
      let rows = cluster.items.map(x => {
        // Normalize keys (studentName vs display_name, etc)
        const name = x.studentName || x.display_name || "ŸÖÿ≥ÿ™ÿÆÿØŸÖ";
        
        // Determine type
        const type = (x.stopType || x.stop_type || "").toLowerCase().trim();
        
        let details = "";
        
        if (type === 'employee') {
            details = "ŸÖŸàÿ∏ŸÅ";
        } else {
            // Handle Grade/Section (camelCase or snake_case)
            const g = x.gradeName || x.grade_name || "";
            const s = x.sectionName || x.section_name || "";
            if (g || s) {
                details = `${g} - ${s}`;
            }
        }

        return `<div style="margin-bottom:6px; border-bottom:1px solid #eee; padding-bottom:4px;">
                 <b>${name}</b><br><span style="font-size:12px; color:#555;">${details}</span>
                </div>`;
      }).join('');
      
      return `<div style="color:black;text-align:right;direction:rtl;min-width:180px;">
                <b style="color:${color}; font-size:14px;">${title}</b><hr>${rows}
              </div>`;
    }

  </script>
</body>
</html>
