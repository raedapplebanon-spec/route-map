<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>All Routes Admin Map</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    #map { height: 100%; width: 100%; }
    
    #pac-input {
      background-color: #fff;
      font-family: Roboto;
      font-size: 15px;
      font-weight: 300;
      margin-left: 12px;
      padding: 0 11px 0 13px;
      text-overflow: ellipsis;
      width: 300px;
      height: 40px;
      margin-top: 10px;
      border: 1px solid #ccc;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      outline: none;
    }

    #legend {
      background: rgba(255, 255, 255, 0.95);
      margin: 10px;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      direction: rtl;
      display: none;
      min-width: 150px;
    }
    .legend-header { font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
    .legend-item { display: flex; align-items: center; margin-bottom: 4px; padding: 2px; }
    .color-box { width: 15px; height: 15px; margin-left: 8px; border-radius: 3px; border: 1px solid #999; }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&callback=initMap&libraries=marker,places,geometry&loading=async&v=weekly" async defer></script>
</head>
<body>

  <input id="pac-input" class="controls" type="text" placeholder="Ø¨Ø­Ø« Ø¹Ù† Ø·Ø§Ù„Ø¨ Ø£Ùˆ Ù…ÙˆÙ‚Ø¹..." />
  <div id="legend"></div>
  <div id="map"></div>

  <script>
    let map, infoWindow;
    let mapReady = false;
    
    // Store active objects
    window.activeRoutes = []; 
    window.availableMarkers = [];

    const COLORS = [
      "#D50000", "#2962FF", "#00C853", "#FF6D00", "#AA00FF", 
      "#00B8D4", "#C51162", "#3E2723", "#2E7D32", "#304FFE"
    ];

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function groupCloseLocations(stops, tolerance = 15) {
      const clusters = [];
      stops.forEach(stop => {
        let placed = false;
        const type = (stop.stopType || "").toLowerCase().trim();
        const shift = (stop.timeShift || "").toUpperCase().trim();

        for (const c of clusters) {
          const d = haversineDistance(c.lat, c.lng, parseFloat(stop.lat), parseFloat(stop.lng));
          if (d < tolerance) {
            c.items.push(stop);
            if (stop.isStart === true) c.isStart = true;
            if (stop.isFinal === true) c.isFinal = true;
            if (type === 'assistant') {
              c.stopType = 'assistant';
              if (shift) c.timeShift = shift;
            }
            c.hideMarker = c.hideMarker && (stop.hideMarker === true || stop.hideMarker === 'true');
            placed = true;
            break;
          }
        }
        if (!placed) {
          clusters.push({
            lat: parseFloat(stop.lat),
            lng: parseFloat(stop.lng),
            items: [stop],
            isStart: stop.isStart === true,
            isFinal: stop.isFinal === true,
            stopType: type,
            timeShift: shift,
            hideMarker: (stop.hideMarker === true || stop.hideMarker === 'true')
          });
        }
      });
      return clusters;
    }

    // --- INIT MAP ---
    // 3. MAIN: Initialize Map
    window.initMap = async function() {
      const { Map } = await google.maps.importLibrary("maps");
      const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");

      infoWindow = new google.maps.InfoWindow();

      map = new Map(document.getElementById("map"), {
        center: { lat: 33.8938, lng: 35.5018 },
        zoom: 10,
        mapTypeControl: true,
        streetViewControl: false,
        fullscreenControl: false,
        // âœ… THIS FIXES THE ERROR:
        mapId: "48c2bb983bd19c1c44d95cb7" 
      });

      const input = document.getElementById("pac-input");
      const autocomplete = new google.maps.places.Autocomplete(input);
      autocomplete.bindTo("bounds", map);
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

      const legend = document.getElementById("legend");
      map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(legend);

      mapReady = true;
      window.addEventListener("message", handleMessage);
      
      console.log("âœ… Map Initialized (Multi-Route Version)");
    };

    function handleMessage(event) {
      if (!event.data) return;
      let data = event.data;
      if (typeof data === 'string') {
        try { data = JSON.parse(data); } catch(e) { return; }
      }
      
      if (data.action === "setRouteData") {
        if (data.routesGrouped && data.routesGrouped.length > 0) {
           console.log(`ðŸ“¦ Received ${data.routesGrouped.length} Separate Routes.`);
           renderAllRoutes(data.routesGrouped, data.availableData);
        } else if (data.routeData && data.routeData.length > 0) {
           console.warn("âš ï¸ Warning: Received Flat List. Grouping logic missing in Flutter.");
           const fakeGroup = [{ routeId: "default", points: data.routeData }];
           renderAllRoutes(fakeGroup, data.availableData);
        } else {
           renderAllRoutes([], data.availableData);
        }
      }
    }

    // --- MAIN RENDERER (SEQUENTIAL) ---
    async function renderAllRoutes(groupedRoutes, availableData) {
      if (!mapReady) return;

      // 1. Clear Map
      window.activeRoutes.forEach(r => {
        r.renderer.setMap(null);
        r.markers.forEach(m => m.map = null);
      });
      window.activeRoutes = [];
      window.availableMarkers.forEach(m => m.map = null);
      window.availableMarkers = [];

      const legend = document.getElementById("legend");
      const count = groupedRoutes ? groupedRoutes.length : 0;
      legend.innerHTML = `<div class="legend-header">ØªÙ… Ø§Ø³ØªÙ„Ø§Ù…: ${count} Ø¬ÙˆÙ„Ø§Øª</div>`;
      legend.style.display = "block";

      const bounds = new google.maps.LatLngBounds();

      // 2. Draw Routes One by One (await ensures separation)
      if (groupedRoutes && groupedRoutes.length > 0) {
        let i = 0;
        for (const group of groupedRoutes) {
          const color = COLORS[i % COLORS.length];
          const routeId = group.routeId || "Unknown";
          const points = group.points;

          console.log(`ðŸ”¹ Drawing Route #${i+1} (ID: ${routeId}) with Color: ${color}`);

          legend.innerHTML += `
            <div class="legend-item">
              <div class="color-box" style="background:${color}"></div>
              <span>Ø¬ÙˆÙ„Ø©: ${routeId}</span>
            </div>
          `;

          // This AWAIT is the key. It finishes Route A before touching Route B
          await processSingleRoute(routeId, points, color, bounds);
          i++;
        }
      } else {
        legend.innerHTML += `<div class="legend-item" style="color:red">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬ÙˆÙ„Ø§Øª</div>`;
      }

      // 3. Draw Available
      if (availableData && availableData.length > 0) {
        renderAvailableStudents(availableData, bounds);
      }

      if (!bounds.isEmpty()) {
        map.fitBounds(bounds);
      }
    }

    // --- SINGLE ROUTE PROCESSOR ---
    function processSingleRoute(routeId, rawPoints, color, bounds) {
      return new Promise((resolve) => {
        
        // Group points only for this specific route ID
        const clusters = groupCloseLocations(rawPoints);
        
        // Create dedicated renderer with unique color
        const dService = new google.maps.DirectionsService();
        const dRenderer = new google.maps.DirectionsRenderer({
          map: map,
          suppressMarkers: true,
          preserveViewport: true,
          polylineOptions: { strokeColor: color, strokeOpacity: 0.8, strokeWeight: 6 }
        });

        const routeObj = { renderer: dRenderer, markers: [], routeId: routeId };
        window.activeRoutes.push(routeObj);

        // Draw Markers
        clusters.forEach(cluster => {
          if (cluster.hideMarker) return;
          const pos = { lat: cluster.lat, lng: cluster.lng };
          bounds.extend(pos);

          let pinText = "...";
          let pinHeader = "Ù†Ù‚Ø·Ø© ØªÙˆÙ‚Ù";
          let borderColor = color;

          if (cluster.isStart) {
            pinText = "S"; pinHeader = "Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"; borderColor = "#000";
          } else if (cluster.isFinal) {
            pinText = "E"; pinHeader = "Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©"; borderColor = "#000";
          } else if (cluster.stopType === 'assistant') {
            pinText = cluster.timeShift === 'AM' ? "A" : "P";
            pinHeader = "Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ (" + cluster.timeShift + ")";
            borderColor = "#000";
          }

          const html = buildInfoWindowHtml(cluster, pinHeader, color);
          const marker = createAdvancedMarker(pos, color, pinText, html, borderColor);
          routeObj.markers.push(marker);
        });

        // Optimization Logic
        const startPoint = clusters.find(c => c.isStart);
        const endPoint = clusters.find(c => c.isFinal);

        if (!startPoint || !endPoint) {
          console.warn(`âš ï¸ Route ${routeId} skipped calculation (Missing Start/End)`);
          resolve(); 
          return;
        }

        const assistantAM = clusters.find(c => c.stopType === 'assistant' && c.timeShift === 'AM');
        const assistantPM = clusters.find(c => c.stopType === 'assistant' && c.timeShift === 'PM');
        
        const studentStops = clusters.filter(c => 
          c !== startPoint && c !== endPoint && c !== assistantAM && c !== assistantPM
        );

        const virtualOrigin = assistantAM || startPoint;
        const virtualDest = assistantPM || endPoint;

        // Calc Route
        if (studentStops.length > 0) {
          dService.route({
            origin: { lat: virtualOrigin.lat, lng: virtualOrigin.lng },
            destination: { lat: virtualDest.lat, lng: virtualDest.lng },
            waypoints: studentStops.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: true })),
            travelMode: google.maps.TravelMode.DRIVING,
            optimizeWaypoints: true,
          }, (result, status) => {
            if (status === "OK") {
              const optimizedOrder = result.routes[0].waypoint_order;
              const sortedStudents = optimizedOrder.map(index => studentStops[index]);

              const finalWaypoints = [];
              if (assistantAM) finalWaypoints.push({ location: { lat: assistantAM.lat, lng: assistantAM.lng }, stopover: true });
              sortedStudents.forEach(s => finalWaypoints.push({ location: { lat: s.lat, lng: s.lng }, stopover: true }));
              if (assistantPM) finalWaypoints.push({ location: { lat: assistantPM.lat, lng: assistantPM.lng }, stopover: true });

              drawFinalPolyline(dService, dRenderer, startPoint, endPoint, finalWaypoints, resolve);
            } else {
              console.error(`Route ${routeId} Calc Failed: ${status}`);
              resolve();
            }
          });
        } else {
          // Simple Route (Start -> [Assistants] -> End)
          const simpleWaypoints = [];
          if (assistantAM) simpleWaypoints.push({ location: { lat: assistantAM.lat, lng: assistantAM.lng }, stopover: true });
          if (assistantPM) simpleWaypoints.push({ location: { lat: assistantPM.lat, lng: assistantPM.lng }, stopover: true });
          drawFinalPolyline(dService, dRenderer, startPoint, endPoint, simpleWaypoints, resolve);
        }
      });
    }

    function drawFinalPolyline(service, renderer, start, end, waypoints, onComplete) {
      service.route({
        origin: { lat: start.lat, lng: start.lng },
        destination: { lat: end.lat, lng: end.lng },
        waypoints: waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false,
      }, (result, status) => {
        if (status === "OK") {
          renderer.setDirections(result);
        }
        onComplete();
      });
    }

    function renderAvailableStudents(points, bounds) {
      const clusters = groupCloseLocations(points);
      const color = "#9E9E9E";
      clusters.forEach(cluster => {
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);
        const html = buildInfoWindowHtml(cluster, "Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¬ÙˆÙ„Ø©", color);
        const marker = createAdvancedMarker(pos, color, cluster.items.length.toString(), html, "#333");
        window.availableMarkers.push(marker);
      });
    }

    function createAdvancedMarker(pos, color, text, html, borderColor = "#FFF") {
      const pin = new google.maps.marker.PinElement({
        background: color,
        borderColor: borderColor,
        glyphColor: "#FFFFFF",
        glyphText: text 
      });
      const marker = new google.maps.marker.AdvancedMarkerElement({
        map: map,
        position: pos,
        content: pin.element,
        gmpClickable: true
      });
      marker.addListener("click", () => {
        infoWindow.setContent(html);
        infoWindow.open(map, marker);
      });
      return marker;
    }

    function buildInfoWindowHtml(cluster, title, color) {
      let rows = cluster.items.map(x => {
        let name = x.studentName || "Ø·Ø§Ù„Ø¨";
        let details = (x.gradeName || "") + " " + (x.sectionName || "");
        return `<div style="margin-bottom:6px; border-bottom:1px solid #eee; padding-bottom:4px;">
                  <b>${name}</b><br><span style="font-size:12px; color:#555;">${details}</span>
                </div>`;
      }).join('');
      return `<div style="color:black;text-align:right;direction:rtl;min-width:180px;">
                <b style="color:${color}; font-size:14px;">${title}</b><hr>${rows}
              </div>`;
    }

  </script>
</body>
</html>
