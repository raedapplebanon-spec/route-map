<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>All Routes Admin Map</title>
  <style>
    /* ✅ 1. Layout Settings */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: "Segoe UI", Tahoma, sans-serif;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    /* ✅ 2. Search Box (Hidden by default, NO !important) */
    #pac-input {
      display: none; /* Hidden until map loads */
      background-color: #fff;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      font-size: 14px;
      font-weight: 500;
      margin-top: 10px;
      margin-left: 10px;
      padding: 0 12px;
      text-overflow: ellipsis;
      width: 280px;
      height: 40px;
      border-radius: 8px;
      border: 1px solid #ddd;
      box-shadow: 0 4px 6px rgba(0,0,0,0.15);
      outline: none;
      direction: rtl;
    }

    #pac-input:focus {
      border-color: #4d90fe;
    }

    /* ✅ 3. Legend (Hidden by default, NO !important) */
    #legend {
      display: none; /* Hidden until data arrives */
      background: rgba(255, 255, 255, 0.95);
      margin: 12px;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      max-height: 300px;
      overflow-y: auto;
      direction: rtl;
      min-width: 160px;
      border: 1px solid #eee;
    }

    .legend-header {
      font-weight: bold;
      margin-bottom: 8px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 6px;
      color: #333;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      padding: 2px 0;
    }

    .color-box {
      width: 14px;
      height: 14px;
      margin-left: 8px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.1);
    }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&libraries=places,marker&callback=initMap&loading=async&v=weekly" async defer></script>
</head>
<body>

  <input id="pac-input" class="controls" type="text" placeholder="بحث عن طالب أو موقع..." />
  <div id="legend"></div>
  
  <div id="map"></div>

  <script>
    let map, infoWindow;
    let mapReady = false;
    
    // Store active objects
    window.activeRoutes = []; 
    window.availableMarkers = [];

    const COLORS = [
      "#D50000", "#2962FF", "#00C853", "#FF6D00", "#AA00FF", 
      "#00B8D4", "#C51162", "#3E2723", "#2E7D32", "#304FFE"
    ];

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function groupCloseLocations(stops, tolerance = 15) {
      const clusters = [];
      stops.forEach(stop => {
        let placed = false;
        const type = (stop.stopType || "").toLowerCase().trim();
        const shift = (stop.timeShift || "").toUpperCase().trim();

        for (const c of clusters) {
          const d = haversineDistance(c.lat, c.lng, parseFloat(stop.lat), parseFloat(stop.lng));
          if (d < tolerance) {
            c.items.push(stop);
            if (stop.isStart === true) c.isStart = true;
            if (stop.isFinal === true) c.isFinal = true;
            if (type === 'assistant') {
              c.stopType = 'assistant';
              if (shift) c.timeShift = shift;
            }
            c.hideMarker = c.hideMarker && (stop.hideMarker === true || stop.hideMarker === 'true');
            placed = true;
            break;
          }
        }
        if (!placed) {
          clusters.push({
            lat: parseFloat(stop.lat),
            lng: parseFloat(stop.lng),
            items: [stop],
            isStart: stop.isStart === true,
            isFinal: stop.isFinal === true,
            stopType: type,
            timeShift: shift,
            hideMarker: (stop.hideMarker === true || stop.hideMarker === 'true')
          });
        }
      });
      return clusters;
    }

    // --- INIT MAP ---
    window.initMap = async function() {
      const { Map } = await google.maps.importLibrary("maps");
      const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");

      infoWindow = new google.maps.InfoWindow();

      map = new Map(document.getElementById("map"), {
        center: { lat: 32.028031, lng: 35.704308 },
        zoom: 13,
        mapTypeControl: true,
        streetViewControl: false,
        fullscreenControl: false,
        mapId: "48c2bb983bd19c1c44d95cb7" 
      });

      const input = document.getElementById("pac-input");
      const legend = document.getElementById("legend");
      
      const autocomplete = new google.maps.places.Autocomplete(input);
      autocomplete.bindTo("bounds", map);
      
      // Push controls to map
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
      map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(legend);

      // ✅ FIX: Reveal Search Box ONLY after map tiles load (Smooth!)
      google.maps.event.addListenerOnce(map, 'tilesloaded', () => {
         input.style.display = "block"; 
      });

      mapReady = true;
      window.addEventListener("message", handleMessage);
      
      console.log("✅ Map Initialized");
    };

    function handleMessage(event) {
      if (!event.data) return;
      let data = event.data;
      if (typeof data === 'string') {
        try { data = JSON.parse(data); } catch(e) { return; }
      }
      
      if (data.action === "setRouteData") {
        if (data.routesGrouped && data.routesGrouped.length > 0) {
           renderAllRoutes(data.routesGrouped, data.availableData);
        } else if (data.routeData && data.routeData.length > 0) {
           const fakeGroup = [{ routeId: "default", points: data.routeData }];
           renderAllRoutes(fakeGroup, data.availableData);
        } else {
           renderAllRoutes([], data.availableData);
        }
      }
    }

    // --- MAIN RENDERER ---
    async function renderAllRoutes(groupedRoutes, availableData) {
      if (!mapReady) return;

      // 1. Clear Map
      window.activeRoutes.forEach(r => {
        r.renderer.setMap(null);
        r.markers.forEach(m => m.map = null);
      });
      window.activeRoutes = [];
      window.availableMarkers.forEach(m => m.map = null);
      window.availableMarkers = [];

      const legend = document.getElementById("legend");
      const count = groupedRoutes ? groupedRoutes.length : 0;
      const bounds = new google.maps.LatLngBounds();

      // ✅ Logic: Show legend only if we have routes
      if (count > 0) {
        legend.innerHTML = `<div class="legend-header">تم استلام: ${count} جولات</div>`;
        legend.style.display = "block";
        
        let i = 0;
        for (const group of groupedRoutes) {
          const color = COLORS[i % COLORS.length];
          const routeId = group.routeId || "Unknown";
          const points = group.points;

          legend.innerHTML += `
            <div class="legend-item">
              <div class="color-box" style="background:${color}"></div>
              <span>جولة: ${routeId}</span>
            </div>
          `;

          await processSingleRoute(routeId, points, color, bounds);
          i++;
        }
      } else {
        legend.style.display = "none";
      }

      // 3. Draw Available
      if (availableData && availableData.length > 0) {
        renderAvailableStudents(availableData, bounds);
      }

      if (!bounds.isEmpty()) {
        map.fitBounds(bounds);
      }
    }

    // --- SINGLE ROUTE PROCESSOR ---
    function processSingleRoute(routeId, rawPoints, color, bounds) {
      return new Promise((resolve) => {
        
        const clusters = groupCloseLocations(rawPoints);
        
        const dService = new google.maps.DirectionsService();
        const dRenderer = new google.maps.DirectionsRenderer({
          map: map,
          suppressMarkers: true,
          preserveViewport: true,
          polylineOptions: { strokeColor: color, strokeOpacity: 0.8, strokeWeight: 6 }
        });

        const routeObj = { renderer: dRenderer, markers: [], routeId: routeId };
        window.activeRoutes.push(routeObj);

        // Draw Markers
        clusters.forEach(cluster => {
          if (cluster.hideMarker) return;
          const pos = { lat: cluster.lat, lng: cluster.lng };
          bounds.extend(pos);

          let pinText = "...";
          let pinHeader = "نقطة توقف";
          let borderColor = color;

          if (cluster.isStart) {
            pinText = "S"; pinHeader = "نقطة البداية"; borderColor = "#000";
          } else if (cluster.isFinal) {
            pinText = "E"; pinHeader = "نقطة النهاية"; borderColor = "#000";
          } else if (cluster.stopType === 'assistant') {
            pinText = cluster.timeShift === 'AM' ? "A" : "P";
            pinHeader = "المساعد (" + cluster.timeShift + ")";
            borderColor = "#000";
          }

          const html = buildInfoWindowHtml(cluster, pinHeader, color);
          const marker = createAdvancedMarker(pos, color, pinText, html, borderColor);
          routeObj.markers.push(marker);
        });

        // Optimization
        const startPoint = clusters.find(c => c.isStart);
        const endPoint = clusters.find(c => c.isFinal);

        if (!startPoint || !endPoint) {
          resolve(); 
          return;
        }

        const assistantAM = clusters.find(c => c.stopType === 'assistant' && c.timeShift === 'AM');
        const assistantPM = clusters.find(c => c.stopType === 'assistant' && c.timeShift === 'PM');
        
        const studentStops = clusters.filter(c => 
          c !== startPoint && c !== endPoint && c !== assistantAM && c !== assistantPM
        );

        const virtualOrigin = assistantAM || startPoint;
        const virtualDest = assistantPM || endPoint;

        if (studentStops.length > 0) {
          dService.route({
            origin: { lat: virtualOrigin.lat, lng: virtualOrigin.lng },
            destination: { lat: virtualDest.lat, lng: virtualDest.lng },
            waypoints: studentStops.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: true })),
            travelMode: google.maps.TravelMode.DRIVING,
            optimizeWaypoints: true,
          }, (result, status) => {
            if (status === "OK") {
              const optimizedOrder = result.routes[0].waypoint_order;
              const sortedStudents = optimizedOrder.map(index => studentStops[index]);

              const finalWaypoints = [];
              if (assistantAM) finalWaypoints.push({ location: { lat: assistantAM.lat, lng: assistantAM.lng }, stopover: true });
              sortedStudents.forEach(s => finalWaypoints.push({ location: { lat: s.lat, lng: s.lng }, stopover: true }));
              if (assistantPM) finalWaypoints.push({ location: { lat: assistantPM.lat, lng: assistantPM.lng }, stopover: true });

              drawFinalPolyline(dService, dRenderer, startPoint, endPoint, finalWaypoints, routeObj, resolve);
            } else {
              resolve();
            }
          });
        } else {
          const simpleWaypoints = [];
          if (assistantAM) simpleWaypoints.push({ location: { lat: assistantAM.lat, lng: assistantAM.lng }, stopover: true });
          if (assistantPM) simpleWaypoints.push({ location: { lat: assistantPM.lat, lng: assistantPM.lng }, stopover: true });
          drawFinalPolyline(dService, dRenderer, startPoint, endPoint, simpleWaypoints, routeObj, resolve);
        }
      });
    }

    function drawFinalPolyline(service, renderer, start, end, waypoints, routeObj, onComplete) {
      service.route({
        origin: { lat: start.lat, lng: start.lng },
        destination: { lat: end.lat, lng: end.lng },
        waypoints: waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false,
      }, (result, status) => {
        if (status === "OK") {
          renderer.setDirections(result);

          waypoints.forEach((wp, index) => {
            const stopNum = (index + 1).toString();
            const m = routeObj.markers.find(mark => 
              Math.abs(mark.position.lat - wp.location.lat) < 0.0005 && 
              Math.abs(mark.position.lng - wp.location.lng) < 0.0005
            );

            if (m && m.content && m.content.glyphText !== "A" && m.content.glyphText !== "P") {
              const bgColor = m.content.background;
              const borderColor = m.content.borderColor;
              const newPin = new google.maps.marker.PinElement({
                background: bgColor,
                borderColor: borderColor,
                glyphColor: "#FFFFFF",
                glyphText: stopNum 
              });
              m.content = newPin.element;
            }
          });
        }
        onComplete();
      });
    }

    function renderAvailableStudents(points, bounds) {
      const clusters = groupCloseLocations(points);
      const color = "#9E9E9E";
      clusters.forEach(cluster => {
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);
        const html = buildInfoWindowHtml(cluster, "خارج الجولة", color);
        const marker = createAdvancedMarker(pos, color, cluster.items.length.toString(), html, "#333");
        window.availableMarkers.push(marker);
      });
    }

    function createAdvancedMarker(pos, color, text, html, borderColor = "#FFF") {
      const pin = new google.maps.marker.PinElement({
        background: color,
        borderColor: borderColor,
        glyphColor: "#FFFFFF",
        glyphText: text 
      });
      const marker = new google.maps.marker.AdvancedMarkerElement({
        map: map,
        position: pos,
        content: pin.element,
        gmpClickable: true
      });
      marker.addListener("click", () => {
        infoWindow.setContent(html);
        infoWindow.open(map, marker);
      });
      return marker;
    }

    function buildInfoWindowHtml(cluster, title, color) {
      let rows = cluster.items.map(x => {
        let name = x.studentName || "طالب";
        let details = (x.gradeName || "") + " " + (x.sectionName || "");
        return `<div style="margin-bottom:6px; border-bottom:1px solid #eee; padding-bottom:4px;">
                  <b>${name}</b><br><span style="font-size:12px; color:#555;">${details}</span>
                </div>`;
      }).join('');
      return `<div style="color:black;text-align:right;direction:rtl;min-width:180px;">
                <b style="color:${color}; font-size:14px;">${title}</b><hr>${rows}
              </div>`;
    }

  </script>
</body>
</html>
