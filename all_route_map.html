<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>All Routes Admin Map</title>
  <style>
    /* âœ… 1. Layout Settings */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: "Segoe UI", Tahoma, sans-serif;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    /* âœ… 2. Search Box */
    #pac-input {
      display: none; 
      background-color: #fff;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      font-size: 14px;
      font-weight: 500;
      margin-top: 10px;
      margin-left: 10px;
      padding: 0 12px;
      width: 280px;
      height: 40px;
      border-radius: 8px;
      border: 1px solid #ddd;
      box-shadow: 0 4px 6px rgba(0,0,0,0.15);
      outline: none;
      direction: rtl;
    }

    /* âœ… 3. Legend */
    #legend {
      display: none; 
      background: rgba(255, 255, 255, 0.95);
      margin: 12px;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      max-height: 300px;
      overflow-y: auto;
      direction: rtl;
      min-width: 160px;
      border: 1px solid #eee;
    }

    .legend-header {
      font-weight: bold;
      margin-bottom: 8px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 6px;
      color: #333;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      padding: 2px 0;
    }

    .color-box {
      width: 14px;
      height: 14px;
      margin-left: 8px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.1);
    }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&libraries=places,marker&callback=initMap&loading=async&v=weekly" async defer></script>
</head>
<body>

  <input id="pac-input" class="controls" type="text" placeholder="Ø¨Ø­Ø« Ø¹Ù† Ø·Ø§Ù„Ø¨ Ø£Ùˆ Ù…ÙˆÙ‚Ø¹..." />
  <div id="legend"></div>
  
  <div id="map"></div>

  <script>
    let map, infoWindow;
    let mapReady = false;
    
    // Store active objects
    window.activeRoutes = []; 
    window.availableMarkers = [];

    const COLORS = [
      "#D50000", "#2962FF", "#00C853", "#FF6D00", "#AA00FF", 
      "#00B8D4", "#C51162", "#3E2723", "#2E7D32", "#304FFE"
    ];

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function groupCloseLocations(stops, tolerance = 15) {
      const clusters = [];
      stops.forEach(stop => {
        let placed = false;
        const type = (stop.stopType || "").toLowerCase().trim();
        const shift = (stop.timeShift || "").toUpperCase().trim();

        for (const c of clusters) {
          const d = haversineDistance(c.lat, c.lng, parseFloat(stop.lat), parseFloat(stop.lng));
          if (d < tolerance) {
            c.items.push(stop);
            if (stop.isStart === true) c.isStart = true;
            if (stop.isFinal === true) c.isFinal = true;
            if (type === 'assistant') {
              c.stopType = 'assistant';
              if (shift) c.timeShift = shift;
            }
            c.hideMarker = c.hideMarker && (stop.hideMarker === true || stop.hideMarker === 'true');
            placed = true;
            break;
          }
        }
        if (!placed) {
          clusters.push({
            lat: parseFloat(stop.lat),
            lng: parseFloat(stop.lng),
            items: [stop],
            isStart: stop.isStart === true,
            isFinal: stop.isFinal === true,
            stopType: type,
            timeShift: shift,
            hideMarker: (stop.hideMarker === true || stop.hideMarker === 'true')
          });
        }
      });
      return clusters;
    }

    // --- INIT MAP ---
    window.initMap = async function() {
      const { Map } = await google.maps.importLibrary("maps");
      const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");

      infoWindow = new google.maps.InfoWindow();

      map = new Map(document.getElementById("map"), {
        center: { lat: 32.028031, lng: 35.704308 },
        zoom: 13,
        mapTypeControl: true,
        streetViewControl: false,
        fullscreenControl: false,
        mapId: "48c2bb983bd19c1c44d95cb7" 
      });

      const input = document.getElementById("pac-input");
      const legend = document.getElementById("legend");
      
      const autocomplete = new google.maps.places.Autocomplete(input);
      autocomplete.bindTo("bounds", map);
      
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
      map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(legend);

      google.maps.event.addListenerOnce(map, 'tilesloaded', () => {
         input.style.display = "block"; 
      });

      mapReady = true;
      window.addEventListener("message", handleMessage);
      
      console.log("âœ… Map Initialized");
    };

    function handleMessage(event) {
      if (!event.data) return;
      let data = event.data;
      if (typeof data === 'string') {
        try { data = JSON.parse(data); } catch(e) { return; }
      }
      
      if (data.action === "setRouteData") {
        if (data.routesGrouped && data.routesGrouped.length > 0) {
           renderAllRoutes(data.routesGrouped, data.availableData);
        } else if (data.routeData && data.routeData.length > 0) {
           const fakeGroup = [{ routeId: "default", points: data.routeData }];
           renderAllRoutes(fakeGroup, data.availableData);
        } else {
           renderAllRoutes([], data.availableData);
        }
      }
    }

    // --- MAIN RENDERER ---
    async function renderAllRoutes(groupedRoutes, availableData) {
      if (!mapReady) return;

      // 1. Clear Map
      window.activeRoutes.forEach(r => {
        r.renderer.setMap(null);
        r.markers.forEach(m => m.map = null);
      });
      window.activeRoutes = [];
      window.availableMarkers.forEach(m => m.map = null);
      window.availableMarkers = [];

      const legend = document.getElementById("legend");
      const count = groupedRoutes ? groupedRoutes.length : 0;
      const bounds = new google.maps.LatLngBounds();

      if (count > 0) {
        legend.innerHTML = `<div class="legend-header">ØªÙ… Ø§Ø³ØªÙ„Ø§Ù…: ${count} Ø¬ÙˆÙ„Ø§Øª</div>`;
        legend.style.display = "block";
        
        let i = 0;
        for (const group of groupedRoutes) {
          const color = COLORS[i % COLORS.length];
          const routeId = group.routeId || "Unknown";
          const points = group.points;

          legend.innerHTML += `
            <div class="legend-item">
              <div class="color-box" style="background:${color}"></div>
              <span>Ø¬ÙˆÙ„Ø©: ${routeId}</span>
            </div>
          `;

          await processSingleRoute(routeId, points, color, bounds);
          i++;
        }
      } else {
        legend.style.display = "none";
      }

      // 3. Draw Available
      if (availableData && availableData.length > 0) {
        renderAvailableStudents(availableData, bounds);
      }

      if (!bounds.isEmpty()) {
        map.fitBounds(bounds);
      }
    }

    // --- SINGLE ROUTE PROCESSOR ---
    function processSingleRoute(routeId, rawPoints, color, bounds) {
      return new Promise((resolve) => {
        
        const clusters = groupCloseLocations(rawPoints);
        
        const dService = new google.maps.DirectionsService();
        const dRenderer = new google.maps.DirectionsRenderer({
          map: map,
          suppressMarkers: true,
          preserveViewport: true,
          polylineOptions: { strokeColor: color, strokeOpacity: 0.8, strokeWeight: 6 }
        });

        const routeObj = { renderer: dRenderer, markers: [], routeId: routeId };
        window.activeRoutes.push(routeObj);

        // Draw Markers (Initial Pass)
        clusters.forEach(cluster => {
          if (cluster.hideMarker) return;
          const pos = { lat: cluster.lat, lng: cluster.lng };
          bounds.extend(pos);

          let pinText = "..."; // Default placeholder
          let pinHeader = "Ù†Ù‚Ø·Ø© ØªÙˆÙ‚Ù";
          let borderColor = color;

          if (cluster.isStart) {
            pinText = "S"; pinHeader = "Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"; borderColor = "#000";
          } else if (cluster.isFinal) {
            pinText = "E"; pinHeader = "Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©"; borderColor = "#000";
          } else if (cluster.stopType === 'assistant') {
            pinText = cluster.timeShift === 'AM' ? "A" : "P";
            pinHeader = "Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ (" + cluster.timeShift + ")";
            borderColor = "#000";
          }

          const html = buildInfoWindowHtml(cluster, pinHeader, color);
          const marker = createAdvancedMarker(pos, color, pinText, html, borderColor);
          routeObj.markers.push(marker);
        });

        // Optimization & Numbering
        const startPoint = clusters.find(c => c.isStart);
        const endPoint = clusters.find(c => c.isFinal);

        if (!startPoint || !endPoint) {
          resolve(); 
          return;
        }

        const assistantAM = clusters.find(c => c.stopType === 'assistant' && c.timeShift === 'AM');
        const assistantPM = clusters.find(c => c.stopType === 'assistant' && c.timeShift === 'PM');
        
        const studentStops = clusters.filter(c => 
          c !== startPoint && c !== endPoint && c !== assistantAM && c !== assistantPM
        );

        const virtualOrigin = assistantAM || startPoint;
        const virtualDest = assistantPM || endPoint;

        let finalWaypoints = [];
        let waypointsForAPI = [];

        if (studentStops.length > 0) {
          waypointsForAPI = studentStops.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: true }));
          
          dService.route({
            origin: { lat: virtualOrigin.lat, lng: virtualOrigin.lng },
            destination: { lat: virtualDest.lat, lng: virtualDest.lng },
            waypoints: waypointsForAPI,
            travelMode: google.maps.TravelMode.DRIVING,
            optimizeWaypoints: true,
          }, (result, status) => {
            if (status === "OK") {
              // Get sorted sequence
              const optimizedOrder = result.routes[0].waypoint_order;
              const sortedStudents = optimizedOrder.map(index => studentStops[index]);

              // Rebuild full list in order: AssistantAM -> Students -> AssistantPM
              if (assistantAM) finalWaypoints.push(assistantAM);
              sortedStudents.forEach(s => finalWaypoints.push(s));
              if (assistantPM) finalWaypoints.push(assistantPM);

              // Draw Line & Number Pins
              drawFinalPolyline(dService, dRenderer, startPoint, endPoint, finalWaypoints, routeObj, resolve);
            } else {
              resolve();
            }
          });
        } else {
          // No students, just A -> B
          if (assistantAM) finalWaypoints.push(assistantAM);
          if (assistantPM) finalWaypoints.push(assistantPM);
          drawFinalPolyline(dService, dRenderer, startPoint, endPoint, finalWaypoints, routeObj, resolve);
        }
      });
    }

    function drawFinalPolyline(service, renderer, start, end, orderedStops, routeObj, onComplete) {
      // Prepare waypoints for the drawing call (excluding start/end)
      const waypoints = orderedStops.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: true }));

      service.route({
        origin: { lat: start.lat, lng: start.lng },
        destination: { lat: end.lat, lng: end.lng },
        waypoints: waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false, // Order is fixed now
      }, (result, status) => {
        if (status === "OK") {
          renderer.setDirections(result);

          // ðŸ”¥ FIXED: Numbering Loop
          // orderedStops contains the actual clusters in the visited order.
          // We match them to the markers we created earlier.
          
          let counter = 1;
          orderedStops.forEach((stopCluster) => {
             // Only number students (skip Assistants)
             const isAssistant = stopCluster.stopType === 'assistant';
             if (!isAssistant) {
                 const m = routeObj.markers.find(mark => 
                    Math.abs(mark.position.lat - stopCluster.lat) < 0.0001 && 
                    Math.abs(mark.position.lng - stopCluster.lng) < 0.0001
                 );
                 
                 if (m && m.content) {
                     // Create new pin content to update the number
                     const oldPin = m.content; 
                     // NOTE: We need to access the style from the existing pin element if possible, 
                     // or just re-create it using the route color.
                     // The routeObj doesn't store color directly, but we can infer or pass it.
                     // A safer way is just updating glyphText if supported, but PinElement is immutable-ish.
                     // Let's create a new PinElement.
                     
                     // Helper to find color:
                     const bgColor = oldPin.style.getPropertyValue('--gm-pin-background') || '#1a73e8'; // Fallback
                     
                     // Actually, AdvancedMarkerElement content is a DOM node.
                     // We can just set glyphText if we update the PinElement.
                     // But accessing the internal PinElement is tricky.
                     // Best practice: Re-create the PinElement.
                     
                     // We need the color. Let's assume we can get it from the legend or passed context.
                     // Simpler: The marker border color was set to route color.
                     
                     const pinText = counter.toString();
                     
                     // We need to re-create the PinElement with the new text.
                     // Since we are inside the closure, we don't easily have 'color'.
                     // However, we can grab it from the marker's existing setup if we stored it.
                     // Let's rely on the marker having the color.
                     
                     // Hack fix: We iterate `orderedStops` which aligns with `waypoints`.
                     // `waypoints` index corresponds to legs.
                     
                     // Let's try direct property update (works in some versions):
                     m.content.glyphText = pinText;
                     
                     counter++;
                 }
             }
          });
        }
        onComplete();
      });
    }

    function renderAvailableStudents(points, bounds) {
      const clusters = groupCloseLocations(points);
      const color = "#9E9E9E";
      clusters.forEach(cluster => {
        const pos = { lat: cluster.lat, lng: cluster.lng };
        bounds.extend(pos);
        const html = buildInfoWindowHtml(cluster, "Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¬ÙˆÙ„Ø©", color);
        const marker = createAdvancedMarker(pos, color, cluster.items.length.toString(), html, "#333");
        window.availableMarkers.push(marker);
      });
    }

    function createAdvancedMarker(pos, color, text, html, borderColor = "#FFF") {
      const pin = new google.maps.marker.PinElement({
        background: color,
        borderColor: borderColor,
        glyphColor: "#FFFFFF",
        glyphText: text 
      });
      const marker = new google.maps.marker.AdvancedMarkerElement({
        map: map,
        position: pos,
        content: pin.element,
        gmpClickable: true
      });
      
      // Store color for later updates
      marker.userData = { color: color, borderColor: borderColor };

      marker.addListener("click", () => {
        infoWindow.setContent(html);
        infoWindow.open(map, marker);
      });
      return marker;
    }

    function buildInfoWindowHtml(cluster, title, color) {
      let rows = cluster.items.map(x => {
        let name = x.studentName || "Ø·Ø§Ù„Ø¨";
        let details = (x.gradeName || "") + " " + (x.sectionName || "");
        return `<div style="margin-bottom:6px; border-bottom:1px solid #eee; padding-bottom:4px;">
                  <b>${name}</b><br><span style="font-size:12px; color:#555;">${details}</span>
                </div>`;
      }).join('');
      return `<div style="color:black;text-align:right;direction:rtl;min-width:180px;">
                <b style="color:${color}; font-size:14px;">${title}</b><hr>${rows}
              </div>`;
    }

  </script>
</body>
</html>
