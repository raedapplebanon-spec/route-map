<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Parent Bus Map</title>
  
  <style>
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    #map { height: 100%; width: 100%; }
    
    .eta-box {
        display: none; 
        position: absolute; 
        top: 20px; 
        right: 20px; 
        background: rgba(255, 255, 255, 0.95); 
        padding: 15px 20px; 
        border-radius: 12px; 
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        z-index: 999;
        text-align: right;
        min-width: 180px;
        border: 1px solid #f0f0f0;
    }
    .eta-time { font-size: 24px; font-weight: 800; color: #1a73e8; display: block; margin-bottom: 5px; }
    .eta-dist { font-size: 14px; color: #555; font-weight: 500; }
    .eta-stops { font-size: 13px; color: #d93025; margin-top: 5px; display: block; font-weight: 600; }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&callback=initMap&libraries=marker,geometry&loading=async&v=weekly" async defer></script>
</head>

<body>
  <div id="eta-box" class="eta-box">
      <span id="eta-time-text" class="eta-time">-- ÿØŸÇŸäŸÇÿ©</span>
      <span id="eta-dist-text" class="eta-dist">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ≠ÿ≥ÿßÿ®...</span>
      <span id="eta-stops-text" class="eta-stops"></span>
  </div>
  
  <div id="map"></div>

  <script>
    const MY_MAP_ID = "48c2bb983bd19c1c44d95cb7";
    const BUS_ICON_URL = "https://raedapplebanon-spec.github.io/route-map/school-bus_6122028.png";
    
    let map, directionsService, activeRenderer, staticRenderer;
    let busMarker = null;
    let mapReady = false;
    let pendingData = null;
    
    let allStops = [];
    let myTargetStop = null;

    // üî• LOCK VARIABLE: Ensures we calculate only ONCE
    let hasCalculatedInitialRoute = false; 

    window.initMap = async function() {
      try {
        const { Map } = await google.maps.importLibrary("maps");
        const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");

        map = new Map(document.getElementById("map"), {
          center: { lat: 33.8938, lng: 35.5018 },
          zoom: 12,
          mapId: MY_MAP_ID,
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false,
          zoomControl: true
        });

        directionsService = new google.maps.DirectionsService();

        // 1. Grey Line (Full Route Context)
        staticRenderer = new google.maps.DirectionsRenderer({
            map: map,
            suppressMarkers: true,
            preserveViewport: true,
            polylineOptions: { strokeColor: "#9aa0a6", strokeOpacity: 0.5, strokeWeight: 5 }
        });

        // 2. Blue Line (Bus -> Home)
        activeRenderer = new google.maps.DirectionsRenderer({
            map: map,
            suppressMarkers: true,
            preserveViewport: true, // Don't zoom out when this draws
            polylineOptions: { strokeColor: "#1a73e8", strokeOpacity: 0.9, strokeWeight: 6 }
        });

        mapReady = true;
        if (pendingData) { window.setParentRoute(pendingData); pendingData = null; }
        sendToFlutter({ action: 'mapIsReady' });
      } catch (e) { console.error("‚ùå initMap Failed:", e); }
    };

    window.addEventListener("message", function (event) {
      if (!event.data) return;
      let data = event.data;
      if (typeof data === 'string') { try { data = JSON.parse(data); } catch(e){} }
      if (data.action === "setParentRoute") {
          if (mapReady) window.setParentRoute(data.stops);
          else pendingData = data.stops;
      }
      if (data.action === "updateBusLocation") window.updateBusLocation(data.lat, data.lng);
    });

    window.setParentRoute = function(stops) {
        if (!stops || stops.length < 2) return;
        allStops = stops; 
        
        // Find Parent's Stop
        const myStops = stops.filter(s => s.isVisible && !s.isStart && !s.isEnd);
        if (myStops.length > 0) myTargetStop = myStops[myStops.length - 1]; 
        else myTargetStop = stops[stops.length - 1]; 

        // Draw Pins
        if (window.myMarkers) window.myMarkers.forEach(m => m.map = null);
        window.myMarkers = [];
        stops.forEach(stop => { if (stop.isVisible) createMarker(stop); });

        // Draw Grey Line (Static Route) Immediately
        drawStaticRoute(stops);
    };

    window.updateBusLocation = function(lat, lng) {
        const busPos = { lat: lat, lng: lng };
        
        // 1. Move Bus Icon (Always happens)
        if (!busMarker) {
            document.getElementById("eta-box").style.display = "block"; // Show box when bus appears
            const img = document.createElement("img");
            img.src = BUS_ICON_URL;
            img.style.width = "45px";
            img.style.height = "45px";
            busMarker = new google.maps.marker.AdvancedMarkerElement({
                map: map,
                position: busPos,
                content: img,
                title: "Bus",
                zIndex: 999
            });
        } else {
            busMarker.position = busPos;
        }

        // 2. Calculate Route & ETA (ONLY ONCE)
        if (!hasCalculatedInitialRoute && myTargetStop) {
            hasCalculatedInitialRoute = true; // üîí Lock it immediately
            calculateOneTimeRoute(busPos);
        }
    };

    function calculateOneTimeRoute(busPos) {
        // Logic: Calculate path from Bus Position (Right Now) -> Target Stop
        
        // Find intermediate stops for accuracy
        let closestIndex = -1;
        let minDistance = Infinity;
        const busLatLng = new google.maps.LatLng(busPos.lat, busPos.lng);

        allStops.forEach((stop, index) => {
            const stopLatLng = new google.maps.LatLng(stop.lat, stop.lng);
            const dist = google.maps.geometry.spherical.computeDistanceBetween(busLatLng, stopLatLng);
            if (dist < minDistance) { minDistance = dist; closestIndex = index; }
        });

        const targetIndex = allStops.indexOf(myTargetStop);

        // Prep Waypoints (Bus -> ... -> Target)
        let waypoints = [];
        if (closestIndex > -1 && closestIndex < targetIndex) {
            // Get stops in between
            const rawSlice = allStops.slice(closestIndex, targetIndex);
            // Filter unique locations to optimize API waypoint limit
            const uniqueSlice = filterUniqueLocations(rawSlice);
            waypoints = uniqueSlice.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: false }));
        }

        // Call API
        directionsService.route({
            origin: busPos,
            destination: { lat: myTargetStop.lat, lng: myTargetStop.lng },
            waypoints: waypoints,
            travelMode: google.maps.TravelMode.DRIVING,
        }, (result, status) => {
            if (status === "OK") {
                // Draw Blue Line
                activeRenderer.setDirections(result);
                
                // Calculate ETA
                let driveTimeSec = 0;
                let distanceMeters = 0;
                result.routes[0].legs.forEach(leg => {
                    driveTimeSec += leg.duration.value;
                    distanceMeters += leg.distance.value;
                });

                // Calculate Stops Buffer
                // We assume waypoints length represents the number of stops
                // (Since we filtered unique locations above)
                const stopsCount = waypoints.length;
                const stopBufferSec = stopsCount * 60; // 1 min per stop

                const totalMinutes = Math.ceil((driveTimeSec + stopBufferSec) / 60);
                const totalKm = (distanceMeters / 1000).toFixed(1);

                // Set Text (Static)
                document.getElementById("eta-time-text").innerText = totalMinutes + " ÿØŸÇŸäŸÇÿ©";
                document.getElementById("eta-dist-text").innerText = totalKm + " ŸÉŸÖ";
                
                if (stopsCount > 0) {
                     document.getElementById("eta-stops-text").innerText = "ŸäŸàÿ¨ÿØ " + stopsCount + " ÿ™ŸàŸÇŸÅ";
                } else {
                     document.getElementById("eta-stops-text").innerText = "ÿ£ŸÜÿ™ ÿßŸÑŸÖÿ≠ÿ∑ÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©";
                }
            } else {
                console.warn("One-Time Route Failed", status);
                document.getElementById("eta-dist-text").innerText = "ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ≠ÿ≥ÿßÿ®";
            }
        });
    }

    function drawStaticRoute(stops) {
        const start = stops[0];
        const end = stops[stops.length - 1];
        // Use filtered waypoints for the grey line too
        const rawWaypoints = stops.slice(1, -1);
        const uniqueWaypoints = filterUniqueLocations(rawWaypoints);
        const waypoints = uniqueWaypoints.map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: false }));

        directionsService.route({
            origin: { lat: start.lat, lng: start.lng },
            destination: { lat: end.lat, lng: end.lng },
            waypoints: waypoints,
            travelMode: google.maps.TravelMode.DRIVING,
        }, (result, status) => {
            if (status === "OK") {
                staticRenderer.setDirections(result);
                // Fit bounds to full route
                const bounds = new google.maps.LatLngBounds();
                stops.forEach(s => bounds.extend({ lat: s.lat, lng: s.lng }));
                map.fitBounds(bounds);
            }
        });
    }

    function filterUniqueLocations(stops) {
        if (!stops || stops.length === 0) return [];
        const uniqueStops = [];
        stops.forEach(stop => {
            const stopLatLng = new google.maps.LatLng(stop.lat, stop.lng);
            let isDuplicate = false;
            for (const existing of uniqueStops) {
                const existingLatLng = new google.maps.LatLng(existing.lat, existing.lng);
                const dist = google.maps.geometry.spherical.computeDistanceBetween(stopLatLng, existingLatLng);
                if (dist < 20) { isDuplicate = true; break; }
            }
            if (!isDuplicate) uniqueStops.push(stop);
        });
        return uniqueStops;
    }

    function createMarker(stop) {
        let pinBackground = "#1a73e8"; 
        let glyphText = "üè†"; 
        if (stop.isStart) { pinBackground = "#00c853"; glyphText = "S"; }
        else if (stop.isEnd) { pinBackground = "#d50000"; glyphText = "E"; }
        const pin = new google.maps.marker.PinElement({ background: pinBackground, borderColor: "#FFFFFF", glyphColor: "#FFFFFF", glyphText: glyphText, scale: 1.0 });
        const marker = new google.maps.marker.AdvancedMarkerElement({ map: map, position: { lat: stop.lat, lng: stop.lng }, content: pin.element, title: stop.name });
        window.myMarkers.push(marker);
    }

    function sendToFlutter(payload) {
        if (window.FlutterChan) window.FlutterChan.postMessage(JSON.stringify(payload));
        else window.parent.postMessage(payload, "*");
    }
  </script>
</body>
</html>
