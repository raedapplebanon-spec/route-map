<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Parent Bus Map</title>
  
  <style>
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    #map { height: 100%; width: 100%; }
    
    .eta-box {
        display: none; 
        position: absolute; 
        top: 20px; 
        right: 20px; 
        background: rgba(255, 255, 255, 0.95); 
        padding: 15px 20px; 
        border-radius: 12px; 
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        z-index: 999;
        text-align: right;
        min-width: 180px;
        border: 1px solid #f0f0f0;
    }
    .eta-time { font-size: 24px; font-weight: 800; color: #1a73e8; display: block; margin-bottom: 5px; }
    .eta-dist { font-size: 14px; color: #555; font-weight: 500; }
    .eta-stops { font-size: 13px; color: #d93025; margin-top: 5px; display: block; font-weight: 600; }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&callback=initMap&libraries=marker,geometry&loading=async&v=weekly" async defer></script>
</head>

<body>
  <div id="eta-box" class="eta-box">
      <span id="eta-time-text" class="eta-time">-- ÿØŸÇŸäŸÇÿ©</span>
      <span id="eta-dist-text" class="eta-dist">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ≠ÿ≥ÿßÿ®...</span>
      <span id="eta-stops-text" class="eta-stops"></span>
  </div>
  
  <div id="map"></div>

  <script>
    // --- Config ---
    const MY_MAP_ID = "48c2bb983bd19c1c44d95cb7";
    const BUS_ICON_URL = "https://raedapplebanon-spec.github.io/route-map/school-bus_6122028.png";
    
    // üß† PHYSICS SETTINGS
    const AVERAGE_SPEED_KMH = 25; // 25 km/h is realistic for a school bus with traffic
    const RECALCULATE_INTERVAL = 5000; // Safe to run every 5s because it's FREE now!

    let map, polyline;
    let busMarker = null;
    let mapReady = false;
    let pendingData = null;
    let allStops = [];
    let myTargetStop = null;
    let lastCalcTime = 0;

    window.initMap = async function() {
      try {
        const { Map } = await google.maps.importLibrary("maps");
        const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");

        map = new Map(document.getElementById("map"), {
          center: { lat: 33.8938, lng: 35.5018 },
          zoom: 12,
          mapId: MY_MAP_ID,
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false,
          zoomControl: true
        });

        // The Blue Line (Drawn manually now, for free)
        polyline = new google.maps.Polyline({
            path: [],
            geodesic: true,
            strokeColor: "#1a73e8",
            strokeOpacity: 0.9,
            strokeWeight: 6,
            map: map
        });

        mapReady = true;
        if (pendingData) { window.setParentRoute(pendingData); pendingData = null; }
        sendToFlutter({ action: 'mapIsReady' });
      } catch (e) { console.error("‚ùå initMap Failed:", e); }
    };

    window.addEventListener("message", function (event) {
      if (!event.data) return;
      let data = event.data;
      if (typeof data === 'string') { try { data = JSON.parse(data); } catch(e){} }
      if (data.action === "setParentRoute") {
          if (mapReady) window.setParentRoute(data.stops);
          else pendingData = data.stops;
      }
      if (data.action === "updateBusLocation") window.updateBusLocation(data.lat, data.lng);
    });

    window.setParentRoute = function(stops) {
        if (!stops || stops.length < 2) return;
        allStops = stops; 
        
        const myStops = stops.filter(s => s.isVisible && !s.isStart && !s.isEnd);
        if (myStops.length > 0) myTargetStop = myStops[myStops.length - 1]; 
        else myTargetStop = stops[stops.length - 1]; 

        // Draw initial pins
        if (window.myMarkers) window.myMarkers.forEach(m => m.map = null);
        window.myMarkers = [];
        stops.forEach(stop => { if (stop.isVisible) createMarker(stop); });

        // Draw grey static line (Full Route) - Low opacity
        const fullPath = stops.map(s => ({ lat: s.lat, lng: s.lng }));
        new google.maps.Polyline({
            path: fullPath,
            geodesic: true,
            strokeColor: "#9aa0a6",
            strokeOpacity: 0.5,
            strokeWeight: 4,
            map: map
        });

        // Fit bounds
        const bounds = new google.maps.LatLngBounds();
        stops.forEach(s => bounds.extend({ lat: s.lat, lng: s.lng }));
        map.fitBounds(bounds);
    };

    window.updateBusLocation = function(lat, lng) {
        const busPos = { lat: lat, lng: lng };
        document.getElementById("eta-box").style.display = "block";

        if (!busMarker) {
            const img = document.createElement("img");
            img.src = BUS_ICON_URL;
            img.style.width = "45px";
            img.style.height = "45px";
            busMarker = new google.maps.marker.AdvancedMarkerElement({
                map: map,
                position: busPos,
                content: img,
                title: "Bus",
                zIndex: 999
            });
        } else {
            busMarker.position = busPos;
        }

        const now = Date.now();
        if (now - lastCalcTime > RECALCULATE_INTERVAL) {
            lastCalcTime = now;
            calculateLocalETA(busPos);
        }
    };

    // --- üß† THE FREE MATH ENGINE ---
    function calculateLocalETA(busPos) {
        if (!myTargetStop || !allStops.length) return;

        const busLatLng = new google.maps.LatLng(busPos.lat, busPos.lng);
        
        // 1. Find Closest Stop Index
        let closestIndex = -1;
        let minDistance = Infinity;

        allStops.forEach((stop, index) => {
            const stopLatLng = new google.maps.LatLng(stop.lat, stop.lng);
            const dist = google.maps.geometry.spherical.computeDistanceBetween(busLatLng, stopLatLng);
            if (dist < minDistance) {
                minDistance = dist;
                closestIndex = index;
            }
        });

        const targetIndex = allStops.indexOf(myTargetStop);

        if (closestIndex > targetIndex) {
            document.getElementById("eta-time-text").innerText = "ŸàÿµŸÑÿ™";
            document.getElementById("eta-dist-text").innerText = "ÿßŸÑÿ≠ÿßŸÅŸÑÿ© ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑŸÖŸàŸÇÿπ";
            document.getElementById("eta-stops-text").innerText = "";
            polyline.setPath([]); 
            return;
        }

        // 2. Build the Path (Bus -> Next Stop -> ... -> Target)
        // This creates the "Blue Line" visually without API
        const pathPoints = [];
        pathPoints.push(busPos); // Start at Bus
        
        // Add all stops from closestIndex to targetIndex
        // (We start from closestIndex because the bus is "at or near" it)
        for (let i = closestIndex; i <= targetIndex; i++) {
            pathPoints.push({ lat: allStops[i].lat, lng: allStops[i].lng });
        }
        
        // Update Line
        polyline.setPath(pathPoints);

        // 3. Calculate Total Distance (Sum of Segments)
        let totalDistanceMeters = 0;
        for (let i = 0; i < pathPoints.length - 1; i++) {
            const p1 = new google.maps.LatLng(pathPoints[i]);
            const p2 = new google.maps.LatLng(pathPoints[i+1]);
            totalDistanceMeters += google.maps.geometry.spherical.computeDistanceBetween(p1, p2);
        }

        // 4. Filter Unique Stops for Time Buffer
        const intermediateStopsRaw = allStops.slice(closestIndex, targetIndex);
        const uniqueIntermediateStops = filterUniqueLocations(intermediateStopsRaw);
        const uniqueStopsCount = uniqueIntermediateStops.length;

        // 5. Physics Formula: Time = (Distance / Speed) + Stop Buffer
        // Speed: 25 km/h = ~416 meters/minute
        const speedMetersPerMin = (AVERAGE_SPEED_KMH * 1000) / 60; 
        
        const driveTimeMinutes = totalDistanceMeters / speedMetersPerMin;
        const stopBufferMinutes = uniqueStopsCount * 1.0; // 1 min per stop
        
        const totalMinutes = Math.ceil(driveTimeMinutes + stopBufferMinutes);
        const totalKm = (totalDistanceMeters / 1000).toFixed(1);

        // 6. Update UI
        document.getElementById("eta-time-text").innerText = totalMinutes + " ÿØŸÇŸäŸÇÿ©";
        document.getElementById("eta-dist-text").innerText = totalKm + " ŸÉŸÖ";
        
        if (uniqueStopsCount > 0) {
            document.getElementById("eta-stops-text").innerText = "ŸäŸàÿ¨ÿØ " + uniqueStopsCount + " ÿ™ŸàŸÇŸÅ ŸÇÿ®ŸÑ ŸàÿµŸàŸÑŸÉ";
        } else {
            document.getElementById("eta-stops-text").innerText = "ÿ£ŸÜÿ™ ÿßŸÑŸÖÿ≠ÿ∑ÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©!";
        }
    }

    function filterUniqueLocations(stops) {
        if (!stops || stops.length === 0) return [];
        const uniqueStops = [];
        stops.forEach(stop => {
            const stopLatLng = new google.maps.LatLng(stop.lat, stop.lng);
            let isDuplicate = false;
            for (const existing of uniqueStops) {
                const existingLatLng = new google.maps.LatLng(existing.lat, existing.lng);
                const dist = google.maps.geometry.spherical.computeDistanceBetween(stopLatLng, existingLatLng);
                if (dist < 20) { isDuplicate = true; break; }
            }
            if (!isDuplicate) uniqueStops.push(stop);
        });
        return uniqueStops;
    }

    function createMarker(stop) {
        let pinBackground = "#1a73e8"; 
        let glyphText = "üè†"; 
        if (stop.isStart) { pinBackground = "#00c853"; glyphText = "S"; }
        else if (stop.isEnd) { pinBackground = "#d50000"; glyphText = "E"; }
        const pin = new google.maps.marker.PinElement({ background: pinBackground, borderColor: "#FFFFFF", glyphColor: "#FFFFFF", glyphText: glyphText, scale: 1.0 });
        const marker = new google.maps.marker.AdvancedMarkerElement({ map: map, position: { lat: stop.lat, lng: stop.lng }, content: pin.element, title: stop.name });
        window.myMarkers.push(marker);
    }

    function sendToFlutter(payload) {
        if (window.FlutterChan) window.FlutterChan.postMessage(JSON.stringify(payload));
        else window.parent.postMessage(payload, "*");
    }
  </script>
</body>
</html>
