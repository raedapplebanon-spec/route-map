<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Parent Bus Map</title>
  
  <style>
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    #map { height: 100%; width: 100%; }
    
    /* Improved ETA Box */
    .eta-box {
        display: none; 
        position: absolute; 
        top: 20px; 
        right: 20px; 
        background: rgba(255, 255, 255, 0.95); 
        padding: 15px 20px; 
        border-radius: 12px; 
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        z-index: 999;
        text-align: right;
        min-width: 180px;
        border: 1px solid #f0f0f0;
    }
    .eta-time { font-size: 24px; font-weight: 800; color: #1a73e8; display: block; margin-bottom: 5px; }
    .eta-dist { font-size: 14px; color: #555; font-weight: 500; }
    .eta-stops { font-size: 13px; color: #d93025; margin-top: 5px; display: block; font-weight: 600; }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&callback=initMap&libraries=marker,geometry&loading=async&v=weekly" async defer></script>
</head>

<body>
  <div id="eta-box" class="eta-box">
      <span id="eta-time-text" class="eta-time">-- ÿØŸÇŸäŸÇÿ©</span>
      <span id="eta-dist-text" class="eta-dist">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ≠ÿ≥ÿßÿ®...</span>
      <span id="eta-stops-text" class="eta-stops"></span>
  </div>
  
  <div id="map"></div>

  <script>
    // --- Config ---
    const MY_MAP_ID = "48c2bb983bd19c1c44d95cb7";
    const BUS_ICON_URL = "https://raedapplebanon-spec.github.io/route-map/school-bus_6122028.png";
    
    // Config: How often to refresh the route (milliseconds) to save API costs
    const RECALCULATE_INTERVAL = 20000; 

    // --- Globals ---
    let map, directionsService, directionsRenderer, staticRenderer;
    let busMarker = null;
    let mapReady = false;
    let pendingData = null;
    
    // Data Storage
    let allStops = [];
    let myTargetStop = null; // The parent's last stop
    let lastCalcTime = 0;

    // --- 1. Initialize Map ---
    window.initMap = async function() {
      try {
        const { Map } = await google.maps.importLibrary("maps");
        const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");

        map = new Map(document.getElementById("map"), {
          center: { lat: 33.8938, lng: 35.5018 },
          zoom: 12,
          mapId: MY_MAP_ID,
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false,
          zoomControl: true
        });

        directionsService = new google.maps.DirectionsService();
        
        // Renderer for the "Active Path" (Bus -> Home) - BLUE
        directionsRenderer = new google.maps.DirectionsRenderer({
            map: map,
            suppressMarkers: true,
            preserveViewport: true,
            polylineOptions: { strokeColor: "#1a73e8", strokeOpacity: 0.9, strokeWeight: 6 }
        });

        // Renderer for the "Full Plan" (Start -> End) - GREY (Context)
        staticRenderer = new google.maps.DirectionsRenderer({
            map: map,
            suppressMarkers: true,
            preserveViewport: true,
            polylineOptions: { strokeColor: "#9aa0a6", strokeOpacity: 0.5, strokeWeight: 4 }
        });

        mapReady = true;
        console.log("‚úÖ Parent Map Initialized");

        if (pendingData) {
            window.setParentRoute(pendingData);
            pendingData = null;
        }

        sendToFlutter({ action: 'mapIsReady' });

      } catch (e) {
        console.error("‚ùå initMap Failed:", e);
      }
    };

    // --- 2. Listen for Flutter ---
    window.addEventListener("message", function (event) {
      if (!event.data) return;
      let data = event.data;
      if (typeof data === 'string') { try { data = JSON.parse(data); } catch(e){} }

      if (data.action === "setParentRoute") {
          if (mapReady) window.setParentRoute(data.stops);
          else pendingData = data.stops;
      }

      if (data.action === "updateBusLocation") {
          window.updateBusLocation(data.lat, data.lng);
      }
    });

    // --- 3. Setup Logic ---
    window.setParentRoute = function(stops) {
        if (!stops || stops.length < 2) return;
        
        allStops = stops; // Save for logic
        
        // 1. Find "My Target Stop" (The last stop assigned to this parent)
        // We look for isVisible=true. If multiple, pick the last one.
        // We ignore "Start" or "End" unless they are the ONLY stops.
        const myStops = stops.filter(s => s.isVisible && !s.isStart && !s.isEnd);
        
        if (myStops.length > 0) {
            myTargetStop = myStops[myStops.length - 1]; // Pick the furthest one
        } else {
            // Fallback: If no specific stop, use the Route End
            myTargetStop = stops[stops.length - 1]; 
        }

        console.log("üéØ Target Stop Selected:", myTargetStop.name);

        // 2. Draw the STATIC Grey line (The full plan)
        drawStaticRoute(stops);

        // 3. Draw Pins
        if (window.myMarkers) window.myMarkers.forEach(m => m.map = null);
        window.myMarkers = [];

        stops.forEach(stop => {
            if (stop.isVisible) createMarker(stop);
        });
        
        // Fit bounds to show everything initially
        const bounds = new google.maps.LatLngBounds();
        stops.forEach(s => bounds.extend({ lat: s.lat, lng: s.lng }));
        map.fitBounds(bounds);
    };

    // --- 4. Live Updates ---
    window.updateBusLocation = function(lat, lng) {
        const busPos = { lat: lat, lng: lng };
        
        document.getElementById("eta-box").style.display = "block";

        // A. Move Marker
        if (!busMarker) {
            const img = document.createElement("img");
            img.src = BUS_ICON_URL;
            img.style.width = "45px";
            img.style.height = "45px";
            busMarker = new google.maps.marker.AdvancedMarkerElement({
                map: map,
                position: busPos,
                content: img,
                title: "Bus",
                zIndex: 999
            });
        } else {
            busMarker.position = busPos;
        }

        // B. Recalculate Route (Throttled)
        const now = Date.now();
        if (now - lastCalcTime > RECALCULATE_INTERVAL) {
            lastCalcTime = now;
            calculateDynamicRoute(busPos);
        }
    };

    // --- 5. The Brain: Dynamic Routing & Time Calculation ---
    function calculateDynamicRoute(busPos) {
        if (!myTargetStop || !allStops.length) return;

        // 1. Find where the bus is relative to the list of stops
        // We find the "Closest Next Stop" index
        let closestIndex = -1;
        let minDistance = Infinity;
        const busLatLng = new google.maps.LatLng(busPos.lat, busPos.lng);

        allStops.forEach((stop, index) => {
            const stopLatLng = new google.maps.LatLng(stop.lat, stop.lng);
            const dist = google.maps.geometry.spherical.computeDistanceBetween(busLatLng, stopLatLng);
            if (dist < minDistance) {
                minDistance = dist;
                closestIndex = index;
            }
        });

        // 2. Determine Target Index
        const targetIndex = allStops.indexOf(myTargetStop);

        // Safety: If bus passed the target, just show "Arrived"
        if (closestIndex > targetIndex) {
            document.getElementById("eta-time-text").innerText = "ŸàÿµŸÑÿ™";
            document.getElementById("eta-dist-text").innerText = "ÿßŸÑÿ≠ÿßŸÅŸÑÿ© ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑŸÖŸàŸÇÿπ";
            document.getElementById("eta-stops-text").innerText = "";
            directionsRenderer.setDirections({ routes: [] }); // Clear line
            return;
        }

        // 3. Count stops in between (for the +1 min logic)
        // We count stops strictly BETWEEN bus and target
        let stopsInBetweenCount = targetIndex - closestIndex;
        if (stopsInBetweenCount < 0) stopsInBetweenCount = 0;

        // 4. Build Waypoints to force the route to follow the bus path
        // We slice the array from Next Stop -> Target
        // Limit waypoints to ~10 to avoid API errors/cost
        const intermediateStops = allStops.slice(closestIndex, targetIndex);
        const waypoints = intermediateStops.map(s => ({
            location: { lat: s.lat, lng: s.lng },
            stopover: false
        }));

        // 5. Call API
        directionsService.route({
            origin: busPos,
            destination: { lat: myTargetStop.lat, lng: myTargetStop.lng },
            waypoints: waypoints,
            travelMode: google.maps.TravelMode.DRIVING,
        }, (result, status) => {
            if (status === "OK") {
                directionsRenderer.setDirections(result);
                
                // 6. Calculate Times
                const routeLeg = result.routes[0].legs[0];
                let driveTimeSec = 0;
                let distanceMeters = 0;
                
                result.routes[0].legs.forEach(leg => {
                    driveTimeSec += leg.duration.value;
                    distanceMeters += leg.distance.value;
                });

                // üî• THE FORMULA: Drive Time + (Stops * 60s)
                const stopBufferSec = stopsInBetweenCount * 60;
                const totalSeconds = driveTimeSec + stopBufferSec;
                const totalMinutes = Math.ceil(totalSeconds / 60);
                const totalKm = (distanceMeters / 1000).toFixed(1);

                // 7. Update UI
                document.getElementById("eta-time-text").innerText = totalMinutes + " ÿØŸÇŸäŸÇÿ©";
                document.getElementById("eta-dist-text").innerText = totalKm + " ŸÉŸÖ";
                
                if (stopsInBetweenCount > 0) {
                   document.getElementById("eta-stops-text").innerText = "ŸäŸàÿ¨ÿØ " + stopsInBetweenCount + " ÿ™ŸàŸÇŸÅ ŸÇÿ®ŸÑ ŸàÿµŸàŸÑŸÉ";
                } else {
                   document.getElementById("eta-stops-text").innerText = "ÿ£ŸÜÿ™ ÿßŸÑŸÖÿ≠ÿ∑ÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©!";
                }

            } else {
                console.warn("Dynamic Route Failed", status);
            }
        });
    }

    // --- Helpers ---
    function drawStaticRoute(stops) {
        const start = stops[0];
        const end = stops[stops.length - 1];
        const waypoints = stops.slice(1, -1).map(s => ({ location: { lat: s.lat, lng: s.lng }, stopover: false }));

        directionsService.route({
            origin: { lat: start.lat, lng: start.lng },
            destination: { lat: end.lat, lng: end.lng },
            waypoints: waypoints,
            travelMode: google.maps.TravelMode.DRIVING,
        }, (result, status) => {
            if (status === "OK") staticRenderer.setDirections(result);
        });
    }

    function createMarker(stop) {
        let pinBackground = "#1a73e8"; 
        let glyphText = "üè†"; 

        if (stop.isStart) { pinBackground = "#00c853"; glyphText = "S"; }
        else if (stop.isEnd) { pinBackground = "#d50000"; glyphText = "E"; }

        const pin = new google.maps.marker.PinElement({
            background: pinBackground,
            borderColor: "#FFFFFF",
            glyphColor: "#FFFFFF",
            glyphText: glyphText,
            scale: 1.0
        });

        const marker = new google.maps.marker.AdvancedMarkerElement({
            map: map,
            position: { lat: stop.lat, lng: stop.lng },
            content: pin.element,
            title: stop.name
        });
        
        window.myMarkers.push(marker);
    }

    function sendToFlutter(payload) {
        if (window.FlutterChan) window.FlutterChan.postMessage(JSON.stringify(payload));
        else window.parent.postMessage(payload, "*");
    }
  </script>
</body>
</html>
