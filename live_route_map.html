<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Live Route Tracking</title>
  
  <style>
    /* 1. BASIC RESET */
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; }
    #map { height: 100%; width: 100%; }

    /* 2. LEGEND */
    .legend {
        display: none;
        position: absolute; bottom: 25px; right: 10px;
        background: rgba(255, 255, 255, 0.95);
        padding: 12px 16px; border-radius: 12px;
        font-size: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        z-index: 999; direction: rtl; min-width: 140px; border: 1px solid #eee;
    }
    .legend-row { display: flex; align-items: center; margin-bottom: 8px; }
    .legend-row:last-child { margin-bottom: 0; }
    .legend-color { width: 16px; height: 16px; border-radius: 4px; margin-left: 8px; box-shadow: inset 0 0 2px rgba(0,0,0,0.2); }
    
    /* 3. NEW: ROUTE STATS (Distance & Time) */
    .route-stats {
        display: none; /* Hidden until route loads */
        position: absolute; top: 10px; left: 10px;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px 15px; border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        font-size: 13px; font-weight: bold;
        z-index: 1000; direction: rtl; text-align: right;
        border-right: 4px solid #1a73e8;
    }

    /* 4. MARKER STYLES */
    .bus-marker-container { pointer-events: none; }
    .gm-style-iw { padding: 0 !important; overflow: hidden !important; border-radius: 8px !important; }
    .status-badge { font-size: 11px; padding: 2px 6px; border-radius: 4px; color: white; display: inline-block; margin-left: 5px; }
    .bg-red { background-color: #d32f2f; }
    .bg-green { background-color: #388e3c; }
    .bg-gray { background-color: #757575; }
  </style>

  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCYaJ4Gjq36mq8swYgjNXOYr5mKZi45niA&callback=initMap&libraries=marker,geometry&loading=async&v=weekly" async defer></script>
</head>

<body>
  <div id="map"></div>

  <div id="route-stats" class="route-stats">
      <div id="stats-content">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ≠ÿ≥ÿßÿ®...</div>
  </div>

  <div id="legend" class="legend">
    <div class="legend-row"><div class="legend-color" style="background:#00c853"></div><span>ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ®ÿØÿßŸäÿ© (S)</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#d50000"></div><span>ŸÜŸÇÿ∑ÿ© ÿßŸÑŸÜŸáÿßŸäÿ© (E)</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#1a73e8"></div><span>ŸÜŸÇÿ∑ÿ© ÿ™ŸàŸÇŸÅ</span></div>
    <div class="legend-row"><div class="legend-color" style="background:#FBBC04"></div><span>ÿßŸÑÿ≠ÿßŸÅŸÑÿ© (Live)</span></div>
  </div>

  <script>
    // =========================================================
    // 1. GLOBALS
    // =========================================================
    let map, directionsService, directionsRenderer, infoWindow;
    let routeMarkers = [];
    let busMarker = null;
    let mapReady = false;
    
    // Libraries
    let AdvancedMarkerElement, PinElement;

    // Animation Globals
    let animationFrameId = null;
    const MY_MAP_ID = "48c2bb983bd19c1c44d95cb7"; 

    // =========================================================
    // 2. INITIALIZE MAP
    // =========================================================
    window.initMap = async function() {
      try {
        const { Map } = await google.maps.importLibrary("maps");
        const markerLib = await google.maps.importLibrary("marker");
        AdvancedMarkerElement = markerLib.AdvancedMarkerElement;
        PinElement = markerLib.PinElement;

        map = new Map(document.getElementById("map"), {
          center: { lat: 31.9522, lng: 35.2332 }, 
          zoom: 12,
          mapId: MY_MAP_ID,
          
          // üî• ENABLE SATELLITE MODE TOGGLE HERE
          mapTypeControl: true, 
          mapTypeControlOptions: {
              style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
              position: google.maps.ControlPosition.LEFT_TOP
          },
          streetViewControl: false,
          fullscreenControl: false,
          zoomControlOptions: { position: google.maps.ControlPosition.RIGHT_TOP }
        });

        // Setup UI
        map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById("legend"));
        // Push Stats to top left (below satellite control)
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(document.getElementById("route-stats"));

        infoWindow = new google.maps.InfoWindow();
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            map: map, suppressMarkers: true, preserveViewport: true,
            polylineOptions: { strokeColor: "#1a73e8", strokeOpacity: 0.8, strokeWeight: 5 }
        });

        // Signal Ready
        google.maps.event.addListenerOnce(map, 'tilesloaded', () => {
            document.getElementById("legend").style.display = "block";
            mapReady = true;
            sendToFlutter("mapIsReady"); 
        });

      } catch (e) { console.error("‚ùå Map Init Failed:", e); }
    };

    // =========================================================
    // 3. BRIDGE (CRITICAL FOR MOBILE)
    // =========================================================
    window.handleDirectUpdate = function(lat, lng) {
        updateBusUI({ lat: lat, lng: lng });
    };

    // =========================================================
    // 4. MESSAGE LISTENER
    // =========================================================
    window.addEventListener("message", function (event) {
        if (!event.data) return;
        let data = event.data;
        if (typeof data === 'string') { try { data = JSON.parse(data); } catch(e){} }

        // ROUTE DATA
        if (data.action === "setRouteData" && mapReady) {
            const routePoints = (data.routesGrouped && data.routesGrouped.length > 0) 
                              ? data.routesGrouped[0].points : [];
            renderRouteOnMap(routePoints);
        }

        // BUS DATA
        if (data.action === "updateBusLocation" && mapReady) {
            updateBusUI(data);
        }
    });

    // =========================================================
    // 5. PARENT-STYLE BUS LOGIC
    // =========================================================
    function updateBusUI(data) {
        if (!mapReady) return;
        
        const lat = parseFloat(data.lat);
        const lng = parseFloat(data.lng);
        if (isNaN(lat) || isNaN(lng)) return;
        
        const busPos = { lat, lng };

        if (!busMarker) {
            const busPin = new PinElement({ background: "#FBBC04", glyphText: "üöå", borderColor: "#fff" });
            const container = document.createElement('div');
            container.className = 'bus-marker-container';
            container.appendChild(busPin.element);

            busMarker = new AdvancedMarkerElement({
                map: map,
                position: busPos,
                content: container,
                zIndex: 1000,
                title: "Live Bus"
            });
        } else {
            animateMarker(busMarker, lat, lng);
        }
    }

    function animateMarker(marker, targetLat, targetLng) {
        const startPos = marker.position;
        const startLat = (typeof startPos.lat === 'function') ? startPos.lat() : startPos.lat;
        const startLng = (typeof startPos.lng === 'function') ? startPos.lng() : startPos.lng;

        const startTime = performance.now();
        const duration = 2000; 

        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        function step(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const currentLat = startLat + (targetLat - startLat) * progress;
            const currentLng = startLng + (targetLng - startLng) * progress;

            marker.position = { lat: currentLat, lng: currentLng };

            if (progress < 1) {
                animationFrameId = requestAnimationFrame(step);
            } else {
                animationFrameId = null;
            }
        }
        animationFrameId = requestAnimationFrame(step);
    }

    // =========================================================
    // 6. ROUTE RENDERING (WITH DISTANCE/TIME CALCULATION)
    // =========================================================
    function renderRouteOnMap(points) {
        if (!points || points.length === 0) return;

        routeMarkers.forEach(m => m.map = null);
        routeMarkers = [];
        directionsRenderer.setDirections({ routes: [] });

        // Hide stats initially
        document.getElementById("route-stats").style.display = "none";

        const startPoint = points.find(p => p.isStart);
        const endPoint = points.find(p => p.isFinal);
        const clusters = groupCloseLocations(points);
        const startCluster = clusters.find(c => c.isStart);
        const endCluster = clusters.find(c => c.isEnd);

        if (!startCluster || !endCluster) {
            drawAllPins(clusters); return;
        }

        let allMiddleStops = clusters.filter(c => c !== startCluster && c !== endCluster);
        allMiddleStops.sort((a, b) => (a.minOrder || 9999) - (b.minOrder || 9999));
        
        let activeWaypoints = allMiddleStops
            .filter(c => !c.isExcluded)
            .map(c => ({ location: {lat: c.lat, lng: c.lng}, stopover: true }));

        let visualCounter = 1;
        const finalOrderedList = [startCluster, ...allMiddleStops, endCluster];

        finalOrderedList.forEach(cluster => {
            let color = "#1a73e8"; let text = ""; let header = "ŸÜŸÇÿ∑ÿ© ÿ™ÿ¨ŸÖÿπ";
            
            if (cluster.isStart) { color = "#00c853"; text = "S"; header = "ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ®ÿØÿßŸäÿ©"; }
            else if (cluster.isEnd) { color = "#d50000"; text = "E"; header = "ŸÜŸÇÿ∑ÿ© ÿßŸÑŸÜŸáÿßŸäÿ©"; }
            else if (cluster.stopType === 'assistant') { color = "#9C27B0"; text = "A"; header = "ÿßŸÑŸÖÿ±ÿßŸÅŸÇ"; }
            else {
                text = visualCounter.toString();
                visualCounter++;
                color = cluster.isExcluded ? "#757575" : "#1a73e8";
            }
            createAdvancedMarker(cluster, color, text, header);
        });

        if (activeWaypoints.length > 0 || (startCluster && endCluster)) {
            directionsService.route({
                origin: { lat: startCluster.lat, lng: startCluster.lng },
                destination: { lat: endCluster.lat, lng: endCluster.lng },
                waypoints: activeWaypoints,
                travelMode: google.maps.TravelMode.DRIVING,
                optimizeWaypoints: false
            }, (result, status) => {
                if (status === "OK") {
                    directionsRenderer.setDirections(result);
                    
                    // üî• CALCULATE TOTAL DISTANCE & TIME
                    let totalDist = 0;
                    let totalDur = 0;
                    const route = result.routes[0];
                    if (route && route.legs) {
                        route.legs.forEach(leg => {
                            totalDist += leg.distance.value; // meters
                            totalDur += leg.duration.value; // seconds
                        });
                    }
                    const distKm = (totalDist / 1000).toFixed(1);
                    const durMin = Math.round(totalDur / 60);

                    // SHOW STATS
                    const statsDiv = document.getElementById("route-stats");
                    const statsContent = document.getElementById("stats-content");
                    statsDiv.style.display = "block";
                    statsContent.innerHTML = `üèÅ ÿßŸÑŸÖÿ≥ÿßŸÅÿ©: ${distKm} ŸÉŸÖ <br> ‚è±Ô∏è ÿßŸÑŸàŸÇÿ™: ${durMin} ÿØŸÇŸäŸÇÿ©`;

                    const bounds = new google.maps.LatLngBounds();
                    bounds.union(result.routes[0].bounds);
                    map.fitBounds(bounds);
                }
            });
        }
    }

    // =========================================================
    // 7. HELPER FUNCTIONS
    // =========================================================
    async function createAdvancedMarker(cluster, color, text, headerHtml) {
        const pin = new PinElement({ background: color, borderColor: "#FFFFFF", glyphColor: "#FFFFFF", glyphText: text, scale: 1.1 });
        const marker = new AdvancedMarkerElement({
            map: map, position: { lat: cluster.lat, lng: cluster.lng }, content: pin.element
        });
        
        const contentString = `<div style="padding:5px; direction:rtl; text-align:right;">
            <b style="color:${color}">${headerHtml}</b><br>
            ${cluster.items.map(s => s.studentName).join('<br>')}
        </div>`;

        marker.addListener("click", () => {
            infoWindow.setContent(contentString);
            infoWindow.open(map, marker);
        });
        routeMarkers.push(marker);
    }

    function groupCloseLocations(points) {
      const clusters = [];
      points.forEach(p => {
        if(p.hideMarker) return;
        let placed = false;
        for(const c of clusters) {
           if(haversineDistance(c.lat, c.lng, p.lat, p.lng) < 15) {
             c.items.push(p);
             if(p.isStart) c.isStart = true;
             if(p.isFinal) c.isEnd = true;
             if(p.stopType === 'assistant') c.stopType = 'assistant';
             if(p.stop_order > 0 && p.stop_order < c.minOrder) c.minOrder = p.stop_order;
             placed = true; break;
           }
        }
        if(!placed) {
           clusters.push({
             lat: p.lat, lng: p.lng, items: [p],
             isStart: p.isStart, isEnd: p.isFinal,
             stopType: p.stopType,
             minOrder: (p.stop_order > 0 ? p.stop_order : 9999),
             isExcluded: false
           });
        }
      });
      return clusters;
    }

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3; const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1); const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function drawAllPins(clusters) {
         clusters.forEach(c => {
             let color = c.isStart ? "#00c853" : (c.isEnd ? "#d50000" : "#1a73e8");
             createAdvancedMarker(c, color, "", "ŸÜŸÇÿ∑ÿ©");
         });
         const bounds = new google.maps.LatLngBounds();
         clusters.forEach(c => bounds.extend({lat:c.lat, lng:c.lng}));
         map.fitBounds(bounds);
    }

    function sendToFlutter(payload) {
      const msg = typeof payload === 'string' ? payload : JSON.stringify(payload);
      if (window.FlutterChan) window.FlutterChan.postMessage(msg);
      else window.parent.postMessage(msg, "*");
    }
  </script>
</body>
</html>
